# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "clients.baml": "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\r\n\r\n// Using the new OpenAI Responses API for enhanced formatting\r\nclient<llm> CustomGPT5 {\r\n  provider openai-responses\r\n  options {\r\n    model \"gpt-5\"\r\n    api_key env.OPENAI_API_KEY\r\n  }\r\n}\r\n\r\nclient<llm> CustomGPT5Mini {\r\n  provider openai-responses\r\n  retry_policy Exponential\r\n  options {\r\n    model \"gpt-5-mini\"\r\n    api_key env.OPENAI_API_KEY\r\n  }\r\n}\r\n\r\n// Openai with chat completion\r\nclient<llm> CustomGPT5Chat {\r\n  provider openai\r\n  options {\r\n    model \"gpt-5\"\r\n    api_key env.OPENAI_API_KEY\r\n  }\r\n}\r\n\r\n// Latest Anthropic Claude 4 models\r\nclient<llm> CustomOpus4 {\r\n  provider anthropic\r\n  options {\r\n    model \"claude-opus-4-1-20250805\"\r\n    api_key env.ANTHROPIC_API_KEY\r\n  }\r\n}\r\n\r\nclient<llm> CustomSonnet4 {\r\n  provider anthropic\r\n  options {\r\n    model \"claude-sonnet-4-20250514\"\r\n    api_key env.ANTHROPIC_API_KEY\r\n  }\r\n}\r\n\r\nclient<llm> CustomHaiku {\r\n  provider anthropic\r\n  retry_policy Constant\r\n  options {\r\n    model \"claude-3-5-haiku-20241022\"\r\n    api_key env.ANTHROPIC_API_KEY\r\n  }\r\n}\r\n\r\n// Example Google AI client (uncomment to use)\r\nclient<llm> CustomGemini {\r\n   provider google-ai\r\n   options {\r\n   model \"gemini-2.5-pro\"\r\n   api_key \"AIzaSyALyZNagjSYomCVU7L2jJZiQn9KnPMq_oA\"   \r\n   }\r\n }\r\n\r\n// Example AWS Bedrock client (uncomment to use)\r\n// client<llm> CustomBedrock {\r\n//   provider aws-bedrock\r\n//   options {\r\n//     model \"anthropic.claude-sonnet-4-20250514-v1:0\"\r\n//     region \"us-east-1\"\r\n//     // AWS credentials are auto-detected from env vars\r\n//   }\r\n// }\r\n\r\n// Example Azure OpenAI client (uncomment to use)\r\n// Client Azure OpenAI\r\nclient<llm> CustomAzure {\r\n    provider \"azure-openai\"\r\n    options {\r\n        resource_name \"troil-mgun09nu-swedencentral\"  // Sostituisci con il tuo resource name\r\n        deployment_id \"gpt-4.1\"  // Sostituisci con il tuo deployment name\r\n        model \"gpt-4.1\"\r\n        temperature 0.0\r\n        api_key \"55RL4QlT5x0zBe9PApUkqSn3RFLGyPeSCrFD46nbPpVWMwWXbJAdJQQJ99BJACfhMk5XJ3w3AAAAACOGMX7A\"\r\n        api_version \"2024-12-01-preview\"\r\n    }\r\n}\r\n// Per modelli Mistral (Codestral) tramite TogetherAI\r\nclient<llm> CustomCodestral {\r\n  provider openai-generic\r\n  options {\r\n    // Usa la chiave che hai creato su TogetherAI\r\n    api_key env.TOGETHER_API_KEY\r\n\r\n    // Questo è l'endpoint di TogetherAI\r\n    base_url \"https://api.together.xyz/v1\"\r\n\r\n    // Questo è il nome del modello su TogetherAI\r\n    model \"codestral/codestral-latest\"\r\n  }\r\n}\r\n\r\n// Per modelli DeepSeek (specializzati in codice) tramite TogetherAI\r\nclient<llm> CustomDeepSeekCoder {\r\n  provider openai-generic\r\n  options {\r\n    api_key \"sk-e7b7173a4d844002967485e7c066fb8f\"\r\n    base_url \"https://api.deepseek.com\"\r\n\r\n    // Un modello eccellente e incredibilmente economico per il codice\r\n    model \"deepseek-reasoner\" \r\n  }\r\n}\r\n// Example Vertex AI client (uncomment to use)\r\nclient<llm> CustomVertex {\r\n   provider vertex-ai\r\n   options {\r\n   model \"gemini-2.5-pro\"\r\n   location \"us-central1\"\r\n//     // Uses Google Cloud Application Default Credentials\r\n   }\r\n}\r\n// Example Ollama client for local models (uncomment to use)\r\n// client<llm> CustomOllama {\r\n//   provider openai-generic\r\n//   options {\r\n//     base_url \"http://localhost:11434/v1\"\r\n//     model \"llama4\"\r\n//     default_role \"user\" // Most local models prefer the user role\r\n//     // No API key needed for local Ollama\r\n//   }\r\n// }\r\n\r\n// https://docs.boundaryml.com/docs/snippets/clients/round-robin\r\nclient<llm> CustomFast {\r\n  provider round-robin\r\n  options {\r\n    // This will alternate between the two clients\r\n    strategy [CustomGPT5Mini, CustomHaiku]\r\n  }\r\n}\r\n\r\n// https://docs.boundaryml.com/docs/snippets/clients/fallback\r\nclient<llm> OpenaiFallback {\r\n  provider fallback\r\n  options {\r\n    // This will try the clients in order until one succeeds\r\n    strategy [CustomGPT5Mini, CustomGPT5]\r\n  }\r\n}\r\n\r\n// https://docs.boundaryml.com/docs/snippets/clients/retry\r\nretry_policy Constant {\r\n  max_retries 3\r\n  strategy {\r\n    type constant_delay\r\n    delay_ms 200\r\n  }\r\n}\r\n\r\nretry_policy Exponential {\r\n  max_retries 2\r\n  strategy {\r\n    type exponential_backoff\r\n    delay_ms 300\r\n    multiplier 1.5\r\n    max_delay_ms 10000\r\n  }\r\n}",
    "extract_actions_azure.baml": "// Funzione per estrarre le azioni dal dominio\r\nfunction ExtractActionsAzure(domain_description: string, object_types: string, object_attributes: string) -> ActionsResult {\r\n    client \"CustomAzure\"\r\n    prompt #\"You are an expert in PDDL action modeling and automated extraction.\r\n\r\nTASK: Extract ALL actions with precise parameters, preconditions, and effects using PDDL semantics.\r\n\r\nCRITICAL RULES:\r\n1. Parameters: List ALL parameters with ?-prefix and correct types\r\n2. Preconditions: Use EXACT attribute names from the provided attributes\r\n3. Effects: Clearly specify ADD/DELETE for boolean predicates, INCREASE/DECREASE for numeric\r\n4. Be explicit about parameter bindings in conditions/effects\r\n5. Extract both explicit actions AND implied actions (e.g., \"load\" implies \"unload\")\r\n\r\nPARAMETER RULES:\r\n- Format: {\"name\": \"?param\", \"type\": \"typename\"}\r\n- Always use ? prefix\r\n- Include ALL objects involved in the action\r\n\r\nPRECONDITION FORMAT:\r\n- For boolean predicates: {\"attribute\": \"pred-name\", \"condition\": \"(?p1 ?p2 ...) = true\"} or \"= false\"\r\n- For numeric: {\"attribute\": \"fuel\", \"condition\": \"> 0\"} or \">= 10\", \"< 100\", etc.\r\n- Be specific about which parameters are used\r\n\r\nEFFECT FORMAT:\r\n- Boolean add: {\"attribute\": \"at\", \"change\": \"add (?r ?loc)\"}\r\n- Boolean delete: {\"attribute\": \"at\", \"change\": \"delete (?r ?old-loc)\"}\r\n- Numeric increase: {\"attribute\": \"fuel\", \"change\": \"decrease by 5\"}\r\n- Numeric set: {\"attribute\": \"battery\", \"change\": \"set to 100\"}\r\n\r\nEXAMPLES:\r\n\r\nExample 1 - Move action:\r\nDomain: \"Robot moves between locations, consuming 1 battery per move. Must have battery > 0.\"\r\nTypes: robot, location\r\nAttributes: robot-at (predicate ?r ?l), battery-level (numeric 0-100)\r\n\r\nOutput:\r\n{\r\n  \"actions\": [\r\n    {\r\n      \"name\": \"move\",\r\n      \"actor\": \"robot\",\r\n      \"parameters\": [\r\n        {\"name\": \"?r\", \"type\": \"robot\"},\r\n        {\"name\": \"?from\", \"type\": \"location\"},\r\n        {\"name\": \"?to\", \"type\": \"location\"}\r\n      ],\r\n      \"preconditions\": [\r\n        {\"attribute\": \"robot-at\", \"condition\": \"(?r ?from) = true\"},\r\n        {\"attribute\": \"battery-level\", \"condition\": \"> 0\"}\r\n      ],\r\n      \"effects\": [\r\n        {\"attribute\": \"robot-at\", \"change\": \"delete (?r ?from)\"},\r\n        {\"attribute\": \"robot-at\", \"change\": \"add (?r ?to)\"},\r\n        {\"attribute\": \"battery-level\", \"change\": \"decrease by 1\"}\r\n      ],\r\n      \"description\": \"Move robot from one location to another, consuming battery\"\r\n    }\r\n  ]\r\n}\r\n\r\nExample 2 - Pickup and drop (implied pair):\r\nDomain: \"Robot picks up package at location. Can carry one at a time.\"\r\nTypes: robot, package, location\r\nAttributes: robot-at, package-at, carrying-package, robot-empty\r\n\r\nOutput:\r\n{\r\n  \"actions\": [\r\n    {\r\n      \"name\": \"pickup\",\r\n      \"actor\": \"robot\",\r\n      \"parameters\": [\r\n        {\"name\": \"?r\", \"type\": \"robot\"},\r\n        {\"name\": \"?p\", \"type\": \"package\"},\r\n        {\"name\": \"?loc\", \"type\": \"location\"}\r\n      ],\r\n      \"preconditions\": [\r\n        {\"attribute\": \"robot-at\", \"condition\": \"(?r ?loc) = true\"},\r\n        {\"attribute\": \"package-at\", \"condition\": \"(?p ?loc) = true\"},\r\n        {\"attribute\": \"robot-empty\", \"condition\": \"(?r) = true\"}\r\n      ],\r\n      \"effects\": [\r\n        {\"attribute\": \"carrying-package\", \"change\": \"add (?r ?p)\"},\r\n        {\"attribute\": \"package-at\", \"change\": \"delete (?p ?loc)\"},\r\n        {\"attribute\": \"robot-empty\", \"change\": \"delete (?r)\"}\r\n      ],\r\n      \"description\": \"Robot picks up a package from the current location\"\r\n    },\r\n    {\r\n      \"name\": \"drop\",\r\n      \"actor\": \"robot\",\r\n      \"parameters\": [\r\n        {\"name\": \"?r\", \"type\": \"robot\"},\r\n        {\"name\": \"?p\", \"type\": \"package\"},\r\n        {\"name\": \"?loc\", \"type\": \"location\"}\r\n      ],\r\n      \"preconditions\": [\r\n        {\"attribute\": \"robot-at\", \"condition\": \"(?r ?loc) = true\"},\r\n        {\"attribute\": \"carrying-package\", \"condition\": \"(?r ?p) = true\"}\r\n      ],\r\n      \"effects\": [\r\n        {\"attribute\": \"carrying-package\", \"change\": \"delete (?r ?p)\"},\r\n        {\"attribute\": \"package-at\", \"change\": \"add (?p ?loc)\"},\r\n        {\"attribute\": \"robot-empty\", \"change\": \"add (?r)\"}\r\n      ],\r\n      \"description\": \"Robot drops a carried package at the current location\"\r\n    }\r\n  ]\r\n}\r\n\r\nExample 3 - Blocksworld stack/unstack:\r\nDomain: \"Stack block A on block B. A must be held, B must be clear.\"\r\nTypes: block, robot-arm\r\nAttributes: held-by-arm, on-block, on-table, clear, arm-empty\r\n\r\nOutput:\r\n{\r\n  \"actions\": [\r\n    {\r\n      \"name\": \"stack\",\r\n      \"actor\": \"robot-arm\",\r\n      \"parameters\": [\r\n        {\"name\": \"?arm\", \"type\": \"robot-arm\"},\r\n        {\"name\": \"?b1\", \"type\": \"block\"},\r\n        {\"name\": \"?b2\", \"type\": \"block\"}\r\n      ],\r\n      \"preconditions\": [\r\n        {\"attribute\": \"held-by-arm\", \"condition\": \"(?b1 ?arm) = true\"},\r\n        {\"attribute\": \"clear\", \"condition\": \"(?b2) = true\"}\r\n      ],\r\n      \"effects\": [\r\n        {\"attribute\": \"held-by-arm\", \"change\": \"delete (?b1 ?arm)\"},\r\n        {\"attribute\": \"on-block\", \"change\": \"add (?b1 ?b2)\"},\r\n        {\"attribute\": \"clear\", \"change\": \"delete (?b2)\"},\r\n        {\"attribute\": \"clear\", \"change\": \"add (?b1)\"},\r\n        {\"attribute\": \"arm-empty\", \"change\": \"add (?arm)\"}\r\n      ],\r\n      \"description\": \"Stack a held block on top of another clear block\"\r\n    },\r\n    {\r\n      \"name\": \"unstack\",\r\n      \"actor\": \"robot-arm\",\r\n      \"parameters\": [\r\n        {\"name\": \"?arm\", \"type\": \"robot-arm\"},\r\n        {\"name\": \"?b1\", \"type\": \"block\"},\r\n        {\"name\": \"?b2\", \"type\": \"block\"}\r\n      ],\r\n      \"preconditions\": [\r\n        {\"attribute\": \"on-block\", \"condition\": \"(?b1 ?b2) = true\"},\r\n        {\"attribute\": \"clear\", \"condition\": \"(?b1) = true\"},\r\n        {\"attribute\": \"arm-empty\", \"condition\": \"(?arm) = true\"}\r\n      ],\r\n      \"effects\": [\r\n        {\"attribute\": \"on-block\", \"change\": \"delete (?b1 ?b2)\"},\r\n        {\"attribute\": \"held-by-arm\", \"change\": \"add (?b1 ?arm)\"},\r\n        {\"attribute\": \"clear\", \"change\": \"add (?b2)\"},\r\n        {\"attribute\": \"clear\", \"change\": \"delete (?b1)\"},\r\n        {\"attribute\": \"arm-empty\", \"change\": \"delete (?arm)\"}\r\n      ],\r\n      \"description\": \"Unstack a block from another and hold it\"\r\n    }\r\n  ]\r\n}\r\n\r\n---\r\n\r\nNOW EXTRACT ACTIONS FROM:\r\n\r\nDomain Description:\r\n{{domain_description}}\r\n\r\nTypes (JSON):\r\n{{object_types}}\r\n\r\nAttributes (JSON):\r\n{{object_attributes}}\r\n\r\nReturn ONLY valid JSON with all actions, including implied inverse actions where appropriate.\r\n\r\n\"#\r\n}",
    "extract_actions_deep.baml": "// Funzione per estrarre le azioni dal dominio\r\nfunction ExtractActionsDeep(domain_description: string, object_types: string, object_attributes: string) -> ActionsResult {\r\n    client \"CustomDeepSeekCoder\"\r\n    prompt #\"You are an expert in PDDL action modeling and automated extraction.\r\n\r\nTASK: Extract ALL actions with precise parameters, preconditions, and effects using PDDL semantics.\r\n\r\nCRITICAL RULES:\r\n1. Parameters: List ALL parameters with ?-prefix and correct types\r\n2. Preconditions: Use EXACT attribute names from the provided attributes\r\n3. Effects: Clearly specify ADD/DELETE for boolean predicates, INCREASE/DECREASE for numeric\r\n4. Be explicit about parameter bindings in conditions/effects\r\n5. Extract both explicit actions AND implied actions (e.g., \"load\" implies \"unload\")\r\n\r\nPARAMETER RULES:\r\n- Format: {\"name\": \"?param\", \"type\": \"typename\"}\r\n- Always use ? prefix\r\n- Include ALL objects involved in the action\r\n\r\nPRECONDITION FORMAT:\r\n- For boolean predicates: {\"attribute\": \"pred-name\", \"condition\": \"(?p1 ?p2 ...) = true\"} or \"= false\"\r\n- For numeric: {\"attribute\": \"fuel\", \"condition\": \"> 0\"} or \">= 10\", \"< 100\", etc.\r\n- Be specific about which parameters are used\r\n\r\nEFFECT FORMAT:\r\n- Boolean add: {\"attribute\": \"at\", \"change\": \"add (?r ?loc)\"}\r\n- Boolean delete: {\"attribute\": \"at\", \"change\": \"delete (?r ?old-loc)\"}\r\n- Numeric increase: {\"attribute\": \"fuel\", \"change\": \"decrease by 5\"}\r\n- Numeric set: {\"attribute\": \"battery\", \"change\": \"set to 100\"}\r\n\r\nEXAMPLES:\r\n\r\nExample 1 - Move action:\r\nDomain: \"Robot moves between locations, consuming 1 battery per move. Must have battery > 0.\"\r\nTypes: robot, location\r\nAttributes: robot-at (predicate ?r ?l), battery-level (numeric 0-100)\r\n\r\nOutput:\r\n{\r\n  \"actions\": [\r\n    {\r\n      \"name\": \"move\",\r\n      \"actor\": \"robot\",\r\n      \"parameters\": [\r\n        {\"name\": \"?r\", \"type\": \"robot\"},\r\n        {\"name\": \"?from\", \"type\": \"location\"},\r\n        {\"name\": \"?to\", \"type\": \"location\"}\r\n      ],\r\n      \"preconditions\": [\r\n        {\"attribute\": \"robot-at\", \"condition\": \"(?r ?from) = true\"},\r\n        {\"attribute\": \"battery-level\", \"condition\": \"> 0\"}\r\n      ],\r\n      \"effects\": [\r\n        {\"attribute\": \"robot-at\", \"change\": \"delete (?r ?from)\"},\r\n        {\"attribute\": \"robot-at\", \"change\": \"add (?r ?to)\"},\r\n        {\"attribute\": \"battery-level\", \"change\": \"decrease by 1\"}\r\n      ],\r\n      \"description\": \"Move robot from one location to another, consuming battery\"\r\n    }\r\n  ]\r\n}\r\n\r\nExample 2 - Pickup and drop (implied pair):\r\nDomain: \"Robot picks up package at location. Can carry one at a time.\"\r\nTypes: robot, package, location\r\nAttributes: robot-at, package-at, carrying-package, robot-empty\r\n\r\nOutput:\r\n{\r\n  \"actions\": [\r\n    {\r\n      \"name\": \"pickup\",\r\n      \"actor\": \"robot\",\r\n      \"parameters\": [\r\n        {\"name\": \"?r\", \"type\": \"robot\"},\r\n        {\"name\": \"?p\", \"type\": \"package\"},\r\n        {\"name\": \"?loc\", \"type\": \"location\"}\r\n      ],\r\n      \"preconditions\": [\r\n        {\"attribute\": \"robot-at\", \"condition\": \"(?r ?loc) = true\"},\r\n        {\"attribute\": \"package-at\", \"condition\": \"(?p ?loc) = true\"},\r\n        {\"attribute\": \"robot-empty\", \"condition\": \"(?r) = true\"}\r\n      ],\r\n      \"effects\": [\r\n        {\"attribute\": \"carrying-package\", \"change\": \"add (?r ?p)\"},\r\n        {\"attribute\": \"package-at\", \"change\": \"delete (?p ?loc)\"},\r\n        {\"attribute\": \"robot-empty\", \"change\": \"delete (?r)\"}\r\n      ],\r\n      \"description\": \"Robot picks up a package from the current location\"\r\n    },\r\n    {\r\n      \"name\": \"drop\",\r\n      \"actor\": \"robot\",\r\n      \"parameters\": [\r\n        {\"name\": \"?r\", \"type\": \"robot\"},\r\n        {\"name\": \"?p\", \"type\": \"package\"},\r\n        {\"name\": \"?loc\", \"type\": \"location\"}\r\n      ],\r\n      \"preconditions\": [\r\n        {\"attribute\": \"robot-at\", \"condition\": \"(?r ?loc) = true\"},\r\n        {\"attribute\": \"carrying-package\", \"condition\": \"(?r ?p) = true\"}\r\n      ],\r\n      \"effects\": [\r\n        {\"attribute\": \"carrying-package\", \"change\": \"delete (?r ?p)\"},\r\n        {\"attribute\": \"package-at\", \"change\": \"add (?p ?loc)\"},\r\n        {\"attribute\": \"robot-empty\", \"change\": \"add (?r)\"}\r\n      ],\r\n      \"description\": \"Robot drops a carried package at the current location\"\r\n    }\r\n  ]\r\n}\r\n\r\nExample 3 - Blocksworld stack/unstack:\r\nDomain: \"Stack block A on block B. A must be held, B must be clear.\"\r\nTypes: block, robot-arm\r\nAttributes: held-by-arm, on-block, on-table, clear, arm-empty\r\n\r\nOutput:\r\n{\r\n  \"actions\": [\r\n    {\r\n      \"name\": \"stack\",\r\n      \"actor\": \"robot-arm\",\r\n      \"parameters\": [\r\n        {\"name\": \"?arm\", \"type\": \"robot-arm\"},\r\n        {\"name\": \"?b1\", \"type\": \"block\"},\r\n        {\"name\": \"?b2\", \"type\": \"block\"}\r\n      ],\r\n      \"preconditions\": [\r\n        {\"attribute\": \"held-by-arm\", \"condition\": \"(?b1 ?arm) = true\"},\r\n        {\"attribute\": \"clear\", \"condition\": \"(?b2) = true\"}\r\n      ],\r\n      \"effects\": [\r\n        {\"attribute\": \"held-by-arm\", \"change\": \"delete (?b1 ?arm)\"},\r\n        {\"attribute\": \"on-block\", \"change\": \"add (?b1 ?b2)\"},\r\n        {\"attribute\": \"clear\", \"change\": \"delete (?b2)\"},\r\n        {\"attribute\": \"clear\", \"change\": \"add (?b1)\"},\r\n        {\"attribute\": \"arm-empty\", \"change\": \"add (?arm)\"}\r\n      ],\r\n      \"description\": \"Stack a held block on top of another clear block\"\r\n    },\r\n    {\r\n      \"name\": \"unstack\",\r\n      \"actor\": \"robot-arm\",\r\n      \"parameters\": [\r\n        {\"name\": \"?arm\", \"type\": \"robot-arm\"},\r\n        {\"name\": \"?b1\", \"type\": \"block\"},\r\n        {\"name\": \"?b2\", \"type\": \"block\"}\r\n      ],\r\n      \"preconditions\": [\r\n        {\"attribute\": \"on-block\", \"condition\": \"(?b1 ?b2) = true\"},\r\n        {\"attribute\": \"clear\", \"condition\": \"(?b1) = true\"},\r\n        {\"attribute\": \"arm-empty\", \"condition\": \"(?arm) = true\"}\r\n      ],\r\n      \"effects\": [\r\n        {\"attribute\": \"on-block\", \"change\": \"delete (?b1 ?b2)\"},\r\n        {\"attribute\": \"held-by-arm\", \"change\": \"add (?b1 ?arm)\"},\r\n        {\"attribute\": \"clear\", \"change\": \"add (?b2)\"},\r\n        {\"attribute\": \"clear\", \"change\": \"delete (?b1)\"},\r\n        {\"attribute\": \"arm-empty\", \"change\": \"delete (?arm)\"}\r\n      ],\r\n      \"description\": \"Unstack a block from another and hold it\"\r\n    }\r\n  ]\r\n}\r\n\r\n---\r\n\r\nNOW EXTRACT ACTIONS FROM:\r\n\r\nDomain Description:\r\n{{domain_description}}\r\n\r\nTypes (JSON):\r\n{{object_types}}\r\n\r\nAttributes (JSON):\r\n{{object_attributes}}\r\n\r\nReturn ONLY valid JSON with all actions, including implied inverse actions where appropriate.\r\n\r\n\"#\r\n}",
    "extract_actions_gemini.baml": "// Definisci la classe per una precondizione\r\nclass Parameters {\r\n  name string @description(\"Il nome del parametro (es: ?r, ?from)\")\r\n  type string @description(\"Il tipo del parametro (es: robot, location)\")\r\n}\r\n\r\nclass Precondition {\r\n    attribute string @description(\"Nome dell'attributo coinvolto (es: loaded, battery, occupied)\")\r\n    condition string @description(\"Condizione richiesta (es: 'must be true', 'must be > 50', 'must be false')\")\r\n}\r\n\r\n// Definisci la classe per un effetto\r\nclass Effect {\r\n    attribute string @description(\"Nome dell'attributo che viene modificato\")\r\n    change string @description(\"Come cambia l'attributo (es: 'set to true', 'increment by 1', 'set to false')\")\r\n}\r\n\r\n// Definisci la classe per un'azione singola\r\nclass Action {\r\n    name string @description(\"Nome dell'azione (es: move, pickup, deliver)\")\r\n    actor string @description(\"Tipo di oggetto che esegue l'azione (es: robot, agent, vehicle)\")\r\n    parameters Parameters[] @description(\"Lista dei parametri coinvolti nell'azione\")\r\n    preconditions Precondition[] @description(\"Lista di precondizioni che devono essere soddisfatte\")\r\n    effects Effect[] @description(\"Lista degli effetti che l'azione produce\")\r\n    description string? @description(\"Descrizione breve dell'azione\")\r\n}\r\n\r\n// Definisci la classe principale per i risultati\r\nclass ActionsResult {\r\n    actions Action[] @description(\"Lista di tutte le azioni con precondizioni e effetti\")\r\n}\r\n\r\n// Funzione per estrarre le azioni dal dominio\r\nfunction ExtractActionsGemini(domain_description: string, object_types: string, object_attributes: string) -> ActionsResult {\r\n    client \"CustomGemini\"\r\n    prompt #\"\r\nYou are an expert in PDDL action modeling and automated extraction.\r\n\r\nTASK: Extract ALL actions with precise parameters, preconditions, and effects using PDDL semantics.\r\n\r\nCRITICAL RULES:\r\n1. Parameters: List ALL parameters with ?-prefix and correct types\r\n2. Preconditions: Use EXACT attribute names from the provided attributes\r\n3. Effects: Clearly specify ADD/DELETE for boolean predicates, INCREASE/DECREASE for numeric\r\n4. Be explicit about parameter bindings in conditions/effects\r\n5. Extract both explicit actions AND implied actions (e.g., \"load\" implies \"unload\")\r\n\r\nPARAMETER RULES:\r\n- Format: {\"name\": \"?param\", \"type\": \"typename\"}\r\n- Always use ? prefix\r\n- Include ALL objects involved in the action\r\n\r\nPRECONDITION FORMAT:\r\n- For boolean predicates: {\"attribute\": \"pred-name\", \"condition\": \"(?p1 ?p2 ...) = true\"} or \"= false\"\r\n- For numeric: {\"attribute\": \"fuel\", \"condition\": \"> 0\"} or \">= 10\", \"< 100\", etc.\r\n- Be specific about which parameters are used\r\n\r\nEFFECT FORMAT:\r\n- Boolean add: {\"attribute\": \"at\", \"change\": \"add (?r ?loc)\"}\r\n- Boolean delete: {\"attribute\": \"at\", \"change\": \"delete (?r ?old-loc)\"}\r\n- Numeric increase: {\"attribute\": \"fuel\", \"change\": \"decrease by 5\"}\r\n- Numeric set: {\"attribute\": \"battery\", \"change\": \"set to 100\"}\r\n\r\nEXAMPLES:\r\n\r\nExample 1 - Move action:\r\nDomain: \"Robot moves between locations, consuming 1 battery per move. Must have battery > 0.\"\r\nTypes: robot, location\r\nAttributes: robot-at (predicate ?r ?l), battery-level (numeric 0-100)\r\n\r\nOutput:\r\n{\r\n  \"actions\": [\r\n    {\r\n      \"name\": \"move\",\r\n      \"actor\": \"robot\",\r\n      \"parameters\": [\r\n        {\"name\": \"?r\", \"type\": \"robot\"},\r\n        {\"name\": \"?from\", \"type\": \"location\"},\r\n        {\"name\": \"?to\", \"type\": \"location\"}\r\n      ],\r\n      \"preconditions\": [\r\n        {\"attribute\": \"robot-at\", \"condition\": \"(?r ?from) = true\"},\r\n        {\"attribute\": \"battery-level\", \"condition\": \"> 0\"}\r\n      ],\r\n      \"effects\": [\r\n        {\"attribute\": \"robot-at\", \"change\": \"delete (?r ?from)\"},\r\n        {\"attribute\": \"robot-at\", \"change\": \"add (?r ?to)\"},\r\n        {\"attribute\": \"battery-level\", \"change\": \"decrease by 1\"}\r\n      ],\r\n      \"description\": \"Move robot from one location to another, consuming battery\"\r\n    }\r\n  ]\r\n}\r\n\r\nExample 2 - Pickup and drop (implied pair):\r\nDomain: \"Robot picks up package at location. Can carry one at a time.\"\r\nTypes: robot, package, location\r\nAttributes: robot-at, package-at, carrying-package, robot-empty\r\n\r\nOutput:\r\n{\r\n  \"actions\": [\r\n    {\r\n      \"name\": \"pickup\",\r\n      \"actor\": \"robot\",\r\n      \"parameters\": [\r\n        {\"name\": \"?r\", \"type\": \"robot\"},\r\n        {\"name\": \"?p\", \"type\": \"package\"},\r\n        {\"name\": \"?loc\", \"type\": \"location\"}\r\n      ],\r\n      \"preconditions\": [\r\n        {\"attribute\": \"robot-at\", \"condition\": \"(?r ?loc) = true\"},\r\n        {\"attribute\": \"package-at\", \"condition\": \"(?p ?loc) = true\"},\r\n        {\"attribute\": \"robot-empty\", \"condition\": \"(?r) = true\"}\r\n      ],\r\n      \"effects\": [\r\n        {\"attribute\": \"carrying-package\", \"change\": \"add (?r ?p)\"},\r\n        {\"attribute\": \"package-at\", \"change\": \"delete (?p ?loc)\"},\r\n        {\"attribute\": \"robot-empty\", \"change\": \"delete (?r)\"}\r\n      ],\r\n      \"description\": \"Robot picks up a package from the current location\"\r\n    },\r\n    {\r\n      \"name\": \"drop\",\r\n      \"actor\": \"robot\",\r\n      \"parameters\": [\r\n        {\"name\": \"?r\", \"type\": \"robot\"},\r\n        {\"name\": \"?p\", \"type\": \"package\"},\r\n        {\"name\": \"?loc\", \"type\": \"location\"}\r\n      ],\r\n      \"preconditions\": [\r\n        {\"attribute\": \"robot-at\", \"condition\": \"(?r ?loc) = true\"},\r\n        {\"attribute\": \"carrying-package\", \"condition\": \"(?r ?p) = true\"}\r\n      ],\r\n      \"effects\": [\r\n        {\"attribute\": \"carrying-package\", \"change\": \"delete (?r ?p)\"},\r\n        {\"attribute\": \"package-at\", \"change\": \"add (?p ?loc)\"},\r\n        {\"attribute\": \"robot-empty\", \"change\": \"add (?r)\"}\r\n      ],\r\n      \"description\": \"Robot drops a carried package at the current location\"\r\n    }\r\n  ]\r\n}\r\n\r\nExample 3 - Blocksworld stack/unstack:\r\nDomain: \"Stack block A on block B. A must be held, B must be clear.\"\r\nTypes: block, robot-arm\r\nAttributes: held-by-arm, on-block, on-table, clear, arm-empty\r\n\r\nOutput:\r\n{\r\n  \"actions\": [\r\n    {\r\n      \"name\": \"stack\",\r\n      \"actor\": \"robot-arm\",\r\n      \"parameters\": [\r\n        {\"name\": \"?arm\", \"type\": \"robot-arm\"},\r\n        {\"name\": \"?b1\", \"type\": \"block\"},\r\n        {\"name\": \"?b2\", \"type\": \"block\"}\r\n      ],\r\n      \"preconditions\": [\r\n        {\"attribute\": \"held-by-arm\", \"condition\": \"(?b1 ?arm) = true\"},\r\n        {\"attribute\": \"clear\", \"condition\": \"(?b2) = true\"}\r\n      ],\r\n      \"effects\": [\r\n        {\"attribute\": \"held-by-arm\", \"change\": \"delete (?b1 ?arm)\"},\r\n        {\"attribute\": \"on-block\", \"change\": \"add (?b1 ?b2)\"},\r\n        {\"attribute\": \"clear\", \"change\": \"delete (?b2)\"},\r\n        {\"attribute\": \"clear\", \"change\": \"add (?b1)\"},\r\n        {\"attribute\": \"arm-empty\", \"change\": \"add (?arm)\"}\r\n      ],\r\n      \"description\": \"Stack a held block on top of another clear block\"\r\n    },\r\n    {\r\n      \"name\": \"unstack\",\r\n      \"actor\": \"robot-arm\",\r\n      \"parameters\": [\r\n        {\"name\": \"?arm\", \"type\": \"robot-arm\"},\r\n        {\"name\": \"?b1\", \"type\": \"block\"},\r\n        {\"name\": \"?b2\", \"type\": \"block\"}\r\n      ],\r\n      \"preconditions\": [\r\n        {\"attribute\": \"on-block\", \"condition\": \"(?b1 ?b2) = true\"},\r\n        {\"attribute\": \"clear\", \"condition\": \"(?b1) = true\"},\r\n        {\"attribute\": \"arm-empty\", \"condition\": \"(?arm) = true\"}\r\n      ],\r\n      \"effects\": [\r\n        {\"attribute\": \"on-block\", \"change\": \"delete (?b1 ?b2)\"},\r\n        {\"attribute\": \"held-by-arm\", \"change\": \"add (?b1 ?arm)\"},\r\n        {\"attribute\": \"clear\", \"change\": \"add (?b2)\"},\r\n        {\"attribute\": \"clear\", \"change\": \"delete (?b1)\"},\r\n        {\"attribute\": \"arm-empty\", \"change\": \"delete (?arm)\"}\r\n      ],\r\n      \"description\": \"Unstack a block from another and hold it\"\r\n    }\r\n  ]\r\n}\r\n\r\n---\r\n\r\nNOW EXTRACT ACTIONS FROM:\r\n\r\nDomain Description:\r\n{{domain_description}}\r\n\r\nTypes (JSON):\r\n{{object_types}}\r\n\r\nAttributes (JSON):\r\n{{object_attributes}}\r\n\r\nReturn ONLY valid JSON with all actions, including implied inverse actions where appropriate.\r\n\"#\r\n}",
    "extract_attributes_azure.baml": "// Funzione per estrarre gli attributi dai tipi di oggetti\r\nfunction ExtractAttributesAzure(object_types: string, domain_description: string) -> AttributesResult {\r\n    client \"CustomAzure\"\r\n    prompt #\"\r\nYou are an expert in PDDL predicate and fluent extraction from natural language.\r\n\r\nTASK: Extract boolean predicates and numeric fluents for each type, following strict PDDL semantics.\r\n\r\nCRITICAL RULES FOR PREDICATES:\r\n1. Each predicate argument MUST have EXACTLY ONE type\r\n2. NEVER use union types like (?x - (block | table)) - THIS IS FORBIDDEN\r\n3. If a concept applies to multiple type combinations, create SEPARATE predicates:\r\n   - (on-table ?b - block) for blocks on table\r\n   - (on-block ?b1 - block ?b2 - block) for blocks on blocks\r\n4. Predicate names should be globally unique OR have different signatures\r\n5. Use descriptive names that clarify the relationship\r\n6. In description, specify full signature: \"Predicate: (name ?param1 - type1 ?param2 - type2)\"\r\n\r\nCRITICAL RULES FOR FLUENTS (numeric):\r\n7. Extract fluents ONLY if explicitly mentioned or strongly implied\r\n8. Specify units and reasonable ranges in description\r\n9. Use hyphens in multi-word names: \"battery-level\", not \"batteryLevel\"\r\n\r\nNAMING CONVENTIONS:\r\n- Use lowercase with hyphens: \"is-loaded\", \"at-location\"\r\n- Avoid ambiguity: prefer \"holding-package\" over just \"holding\"\r\n- For binary relations, make direction clear: \"robot-at-location\" vs \"package-at-location\"\r\n\r\nVALIDATION:\r\n- No attribute name should be repeated with different types across the domain\r\n- Every predicate MUST specify which types it applies to\r\n- Numeric fluents should have plausible ranges\r\n\r\nEXAMPLES:\r\n\r\nExample 1 - Logistics domain (relationships):\r\nTypes: robot, package, location\r\nDescription: \"Robots transport packages between locations. Robots have battery (0-100). Packages have weight.\"\r\n\r\nOutput:\r\n{\r\n  \"types_with_attributes\": [\r\n    {\r\n      \"type_name\": \"robot\",\r\n      \"attributes\": [\r\n        {\"name\": \"robot-at\", \"type\": \"boolean\", \"description\": \"Predicate: (robot-at ?r - robot ?l - location)\"},\r\n        {\"name\": \"battery-level\", \"type\": \"numeric\", \"description\": \"Battery charge percentage (0-100)\"},\r\n        {\"name\": \"carrying-package\", \"type\": \"boolean\", \"description\": \"Predicate: (carrying-package ?r - robot ?p - package)\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"package\",\r\n      \"attributes\": [\r\n        {\"name\": \"package-at\", \"type\": \"boolean\", \"description\": \"Predicate: (package-at ?p - package ?l - location)\"},\r\n        {\"name\": \"weight\", \"type\": \"numeric\", \"description\": \"Weight in kilograms (0-100)\"},\r\n        {\"name\": \"delivered\", \"type\": \"boolean\", \"description\": \"True if package reached destination\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"location\",\r\n      \"attributes\": [\r\n        {\"name\": \"is-depot\", \"type\": \"boolean\", \"description\": \"True if location is a distribution depot\"}\r\n      ]\r\n    }\r\n  ]\r\n}\r\n\r\nExample 2 - Blocksworld (NO hybrid types):\r\nTypes: block, table, robot-arm\r\nDescription: \"Blocks can be on table or on other blocks. Arm picks/puts blocks.\"\r\n\r\nOutput:\r\n{\r\n  \"types_with_attributes\": [\r\n    {\r\n      \"type_name\": \"block\",\r\n      \"attributes\": [\r\n        {\"name\": \"on-table\", \"type\": \"boolean\", \"description\": \"Predicate: (on-table ?b - block)\"},\r\n        {\"name\": \"on-block\", \"type\": \"boolean\", \"description\": \"Predicate: (on-block ?b1 - block ?b2 - block)\"},\r\n        {\"name\": \"clear\", \"type\": \"boolean\", \"description\": \"True if nothing is on top of this block\"},\r\n        {\"name\": \"held-by-arm\", \"type\": \"boolean\", \"description\": \"Predicate: (held-by-arm ?b - block ?a - robot-arm)\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"table\",\r\n      \"attributes\": []\r\n    },\r\n    {\r\n      \"type_name\": \"robot-arm\",\r\n      \"attributes\": [\r\n        {\"name\": \"arm-empty\", \"type\": \"boolean\", \"description\": \"True if arm is not holding anything\"}\r\n      ]\r\n    }\r\n  ]\r\n}\r\n\r\nExample 3 - Rover domain (numeric + boolean):\r\nTypes: rover, location, sample, camera\r\nDescription: \"Rovers navigate locations, collect samples (with mass), and take images. Rovers have fuel.\"\r\n\r\nOutput:\r\n{\r\n  \"types_with_attributes\": [\r\n    {\r\n      \"type_name\": \"rover\",\r\n      \"attributes\": [\r\n        {\"name\": \"rover-at\", \"type\": \"boolean\", \"description\": \"Predicate: (rover-at ?r - rover ?l - location)\"},\r\n        {\"name\": \"fuel\", \"type\": \"numeric\", \"description\": \"Remaining fuel in liters (0-1000)\"},\r\n        {\"name\": \"has-sample\", \"type\": \"boolean\", \"description\": \"Predicate: (has-sample ?r - rover ?s - sample)\"},\r\n        {\"name\": \"equipped-with-camera\", \"type\": \"boolean\", \"description\": \"Predicate: (equipped-with-camera ?r - rover ?c - camera)\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"location\",\r\n      \"attributes\": [\r\n        {\"name\": \"visited\", \"type\": \"boolean\", \"description\": \"True if any rover has been to this location\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"sample\",\r\n      \"attributes\": [\r\n        {\"name\": \"sample-at\", \"type\": \"boolean\", \"description\": \"Predicate: (sample-at ?s - sample ?l - location)\"},\r\n        {\"name\": \"mass\", \"type\": \"numeric\", \"description\": \"Sample mass in grams (1-1000)\"},\r\n        {\"name\": \"analyzed\", \"type\": \"boolean\", \"description\": \"True if sample has been analyzed\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"camera\",\r\n      \"attributes\": [\r\n        {\"name\": \"calibrated\", \"type\": \"boolean\", \"description\": \"True if camera is ready to use\"}\r\n      ]\r\n    }\r\n  ]\r\n}\r\n\r\nExample 4 - Error case to AVOID:\r\n❌ WRONG:\r\n{\"name\": \"on\", \"type\": \"boolean\", \"description\": \"Predicate: (on ?x - (block | table))\"}\r\n\r\n✓ CORRECT:\r\n{\"name\": \"on-table\", \"type\": \"boolean\", \"description\": \"Predicate: (on-table ?b - block)\"}\r\n{\"name\": \"on-block\", \"type\": \"boolean\", \"description\": \"Predicate: (on-block ?b1 - block ?b2 - block)\"}\r\n\r\n---\r\n\r\nNOW PROCESS:\r\n\r\nTypes (JSON):\r\n{{object_types}}\r\n\r\nDomain Description:\r\n{{domain_description}}\r\n\r\nReturn ONLY valid JSON. NO union types. Separate predicates for different type combinations.\r\n\"#\r\n}",
    "extract_attributes_deep.baml": "// Funzione per estrarre gli attributi dai tipi di oggetti\r\nfunction ExtractAttributesDeep(object_types: string, domain_description: string) -> AttributesResult {\r\n    client \"CustomDeepSeekCoder\"\r\n    prompt #\"\r\nYou are an expert in PDDL predicate and fluent extraction from natural language.\r\n\r\nTASK: Extract boolean predicates and numeric fluents for each type, following strict PDDL semantics.\r\n\r\nCRITICAL RULES FOR PREDICATES:\r\n1. Each predicate argument MUST have EXACTLY ONE type\r\n2. NEVER use union types like (?x - (block | table)) - THIS IS FORBIDDEN\r\n3. If a concept applies to multiple type combinations, create SEPARATE predicates:\r\n   - (on-table ?b - block) for blocks on table\r\n   - (on-block ?b1 - block ?b2 - block) for blocks on blocks\r\n4. Predicate names should be globally unique OR have different signatures\r\n5. Use descriptive names that clarify the relationship\r\n6. In description, specify full signature: \"Predicate: (name ?param1 - type1 ?param2 - type2)\"\r\n\r\nCRITICAL RULES FOR FLUENTS (numeric):\r\n7. Extract fluents ONLY if explicitly mentioned or strongly implied\r\n8. Specify units and reasonable ranges in description\r\n9. Use hyphens in multi-word names: \"battery-level\", not \"batteryLevel\"\r\n\r\nNAMING CONVENTIONS:\r\n- Use lowercase with hyphens: \"is-loaded\", \"at-location\"\r\n- Avoid ambiguity: prefer \"holding-package\" over just \"holding\"\r\n- For binary relations, make direction clear: \"robot-at-location\" vs \"package-at-location\"\r\n\r\nVALIDATION:\r\n- No attribute name should be repeated with different types across the domain\r\n- Every predicate MUST specify which types it applies to\r\n- Numeric fluents should have plausible ranges\r\n\r\nEXAMPLES:\r\n\r\nExample 1 - Logistics domain (relationships):\r\nTypes: robot, package, location\r\nDescription: \"Robots transport packages between locations. Robots have battery (0-100). Packages have weight.\"\r\n\r\nOutput:\r\n{\r\n  \"types_with_attributes\": [\r\n    {\r\n      \"type_name\": \"robot\",\r\n      \"attributes\": [\r\n        {\"name\": \"robot-at\", \"type\": \"boolean\", \"description\": \"Predicate: (robot-at ?r - robot ?l - location)\"},\r\n        {\"name\": \"battery-level\", \"type\": \"numeric\", \"description\": \"Battery charge percentage (0-100)\"},\r\n        {\"name\": \"carrying-package\", \"type\": \"boolean\", \"description\": \"Predicate: (carrying-package ?r - robot ?p - package)\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"package\",\r\n      \"attributes\": [\r\n        {\"name\": \"package-at\", \"type\": \"boolean\", \"description\": \"Predicate: (package-at ?p - package ?l - location)\"},\r\n        {\"name\": \"weight\", \"type\": \"numeric\", \"description\": \"Weight in kilograms (0-100)\"},\r\n        {\"name\": \"delivered\", \"type\": \"boolean\", \"description\": \"True if package reached destination\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"location\",\r\n      \"attributes\": [\r\n        {\"name\": \"is-depot\", \"type\": \"boolean\", \"description\": \"True if location is a distribution depot\"}\r\n      ]\r\n    }\r\n  ]\r\n}\r\n\r\nExample 2 - Blocksworld (NO hybrid types):\r\nTypes: block, table, robot-arm\r\nDescription: \"Blocks can be on table or on other blocks. Arm picks/puts blocks.\"\r\n\r\nOutput:\r\n{\r\n  \"types_with_attributes\": [\r\n    {\r\n      \"type_name\": \"block\",\r\n      \"attributes\": [\r\n        {\"name\": \"on-table\", \"type\": \"boolean\", \"description\": \"Predicate: (on-table ?b - block)\"},\r\n        {\"name\": \"on-block\", \"type\": \"boolean\", \"description\": \"Predicate: (on-block ?b1 - block ?b2 - block)\"},\r\n        {\"name\": \"clear\", \"type\": \"boolean\", \"description\": \"True if nothing is on top of this block\"},\r\n        {\"name\": \"held-by-arm\", \"type\": \"boolean\", \"description\": \"Predicate: (held-by-arm ?b - block ?a - robot-arm)\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"table\",\r\n      \"attributes\": []\r\n    },\r\n    {\r\n      \"type_name\": \"robot-arm\",\r\n      \"attributes\": [\r\n        {\"name\": \"arm-empty\", \"type\": \"boolean\", \"description\": \"True if arm is not holding anything\"}\r\n      ]\r\n    }\r\n  ]\r\n}\r\n\r\nExample 3 - Rover domain (numeric + boolean):\r\nTypes: rover, location, sample, camera\r\nDescription: \"Rovers navigate locations, collect samples (with mass), and take images. Rovers have fuel.\"\r\n\r\nOutput:\r\n{\r\n  \"types_with_attributes\": [\r\n    {\r\n      \"type_name\": \"rover\",\r\n      \"attributes\": [\r\n        {\"name\": \"rover-at\", \"type\": \"boolean\", \"description\": \"Predicate: (rover-at ?r - rover ?l - location)\"},\r\n        {\"name\": \"fuel\", \"type\": \"numeric\", \"description\": \"Remaining fuel in liters (0-1000)\"},\r\n        {\"name\": \"has-sample\", \"type\": \"boolean\", \"description\": \"Predicate: (has-sample ?r - rover ?s - sample)\"},\r\n        {\"name\": \"equipped-with-camera\", \"type\": \"boolean\", \"description\": \"Predicate: (equipped-with-camera ?r - rover ?c - camera)\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"location\",\r\n      \"attributes\": [\r\n        {\"name\": \"visited\", \"type\": \"boolean\", \"description\": \"True if any rover has been to this location\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"sample\",\r\n      \"attributes\": [\r\n        {\"name\": \"sample-at\", \"type\": \"boolean\", \"description\": \"Predicate: (sample-at ?s - sample ?l - location)\"},\r\n        {\"name\": \"mass\", \"type\": \"numeric\", \"description\": \"Sample mass in grams (1-1000)\"},\r\n        {\"name\": \"analyzed\", \"type\": \"boolean\", \"description\": \"True if sample has been analyzed\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"camera\",\r\n      \"attributes\": [\r\n        {\"name\": \"calibrated\", \"type\": \"boolean\", \"description\": \"True if camera is ready to use\"}\r\n      ]\r\n    }\r\n  ]\r\n}\r\n\r\nExample 4 - Error case to AVOID:\r\n❌ WRONG:\r\n{\"name\": \"on\", \"type\": \"boolean\", \"description\": \"Predicate: (on ?x - (block | table))\"}\r\n\r\n✓ CORRECT:\r\n{\"name\": \"on-table\", \"type\": \"boolean\", \"description\": \"Predicate: (on-table ?b - block)\"}\r\n{\"name\": \"on-block\", \"type\": \"boolean\", \"description\": \"Predicate: (on-block ?b1 - block ?b2 - block)\"}\r\n\r\n---\r\n\r\nNOW PROCESS:\r\n\r\nTypes (JSON):\r\n{{object_types}}\r\n\r\nDomain Description:\r\n{{domain_description}}\r\n\r\nReturn ONLY valid JSON. NO union types. Separate predicates for different type combinations.\r\n\"#\r\n}",
    "extract_attributes_gemini.baml": "// Definisci la classe per un attributo singolo\r\nclass Attribute {\r\n    name string @description(\"Nome dell'attributo (es: loaded, battery, occupied)\")\r\n    type string @description(\"Tipo dell'attributo: 'boolean' o 'numeric'\")\r\n    description string? @description(\"Descrizione breve dell'attributo\")\r\n}\r\n\r\n// Definisci la classe per gli attributi di un tipo\r\nclass TypeAttributes {\r\n    type_name string @description(\"Nome del tipo di oggetto (es: robot, room, package)\")\r\n    attributes Attribute[] @description(\"Lista di attributi boolean e numeric per questo tipo\")\r\n}\r\n\r\n// Definisci la classe principale per i risultati\r\nclass AttributesResult {\r\n    types_with_attributes TypeAttributes[] @description(\"Lista di tipi di oggetti con i loro attributi\")\r\n}\r\n\r\n// Funzione per estrarre gli attributi dai tipi di oggetti\r\nfunction ExtractAttributesGemini(object_types: string, domain_description: string) -> AttributesResult {\r\n    client \"CustomGemini\"\r\n    prompt #\"You are an expert in PDDL predicate and fluent extraction from natural language.\r\n\r\nTASK: Extract boolean predicates and numeric fluents for each type, following strict PDDL semantics.\r\n\r\nCRITICAL RULES FOR PREDICATES:\r\n1. Each predicate argument MUST have EXACTLY ONE type\r\n2. NEVER use union types like (?x - (block | table)) - THIS IS FORBIDDEN\r\n3. If a concept applies to multiple type combinations, create SEPARATE predicates:\r\n   - (on-table ?b - block) for blocks on table\r\n   - (on-block ?b1 - block ?b2 - block) for blocks on blocks\r\n4. Predicate names should be globally unique OR have different signatures\r\n5. Use descriptive names that clarify the relationship\r\n6. In description, specify full signature: \"Predicate: (name ?param1 - type1 ?param2 - type2)\"\r\n\r\nCRITICAL RULES FOR FLUENTS (numeric):\r\n7. Extract fluents ONLY if explicitly mentioned or strongly implied\r\n8. Specify units and reasonable ranges in description\r\n9. Use hyphens in multi-word names: \"battery-level\", not \"batteryLevel\"\r\n\r\nNAMING CONVENTIONS:\r\n- Use lowercase with hyphens: \"is-loaded\", \"at-location\"\r\n- Avoid ambiguity: prefer \"holding-package\" over just \"holding\"\r\n- For binary relations, make direction clear: \"robot-at-location\" vs \"package-at-location\"\r\n\r\nVALIDATION:\r\n- No attribute name should be repeated with different types across the domain\r\n- Every predicate MUST specify which types it applies to\r\n- Numeric fluents should have plausible ranges\r\n\r\nEXAMPLES:\r\n\r\nExample 1 - Logistics domain (relationships):\r\nTypes: robot, package, location\r\nDescription: \"Robots transport packages between locations. Robots have battery (0-100). Packages have weight.\"\r\n\r\nOutput:\r\n{\r\n  \"types_with_attributes\": [\r\n    {\r\n      \"type_name\": \"robot\",\r\n      \"attributes\": [\r\n        {\"name\": \"robot-at\", \"type\": \"boolean\", \"description\": \"Predicate: (robot-at ?r - robot ?l - location)\"},\r\n        {\"name\": \"battery-level\", \"type\": \"numeric\", \"description\": \"Battery charge percentage (0-100)\"},\r\n        {\"name\": \"carrying-package\", \"type\": \"boolean\", \"description\": \"Predicate: (carrying-package ?r - robot ?p - package)\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"package\",\r\n      \"attributes\": [\r\n        {\"name\": \"package-at\", \"type\": \"boolean\", \"description\": \"Predicate: (package-at ?p - package ?l - location)\"},\r\n        {\"name\": \"weight\", \"type\": \"numeric\", \"description\": \"Weight in kilograms (0-100)\"},\r\n        {\"name\": \"delivered\", \"type\": \"boolean\", \"description\": \"True if package reached destination\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"location\",\r\n      \"attributes\": [\r\n        {\"name\": \"is-depot\", \"type\": \"boolean\", \"description\": \"True if location is a distribution depot\"}\r\n      ]\r\n    }\r\n  ]\r\n}\r\n\r\nExample 2 - Blocksworld (NO hybrid types):\r\nTypes: block, table, robot-arm\r\nDescription: \"Blocks can be on table or on other blocks. Arm picks/puts blocks.\"\r\n\r\nOutput:\r\n{\r\n  \"types_with_attributes\": [\r\n    {\r\n      \"type_name\": \"block\",\r\n      \"attributes\": [\r\n        {\"name\": \"on-table\", \"type\": \"boolean\", \"description\": \"Predicate: (on-table ?b - block)\"},\r\n        {\"name\": \"on-block\", \"type\": \"boolean\", \"description\": \"Predicate: (on-block ?b1 - block ?b2 - block)\"},\r\n        {\"name\": \"clear\", \"type\": \"boolean\", \"description\": \"True if nothing is on top of this block\"},\r\n        {\"name\": \"held-by-arm\", \"type\": \"boolean\", \"description\": \"Predicate: (held-by-arm ?b - block ?a - robot-arm)\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"table\",\r\n      \"attributes\": []\r\n    },\r\n    {\r\n      \"type_name\": \"robot-arm\",\r\n      \"attributes\": [\r\n        {\"name\": \"arm-empty\", \"type\": \"boolean\", \"description\": \"True if arm is not holding anything\"}\r\n      ]\r\n    }\r\n  ]\r\n}\r\n\r\nExample 3 - Rover domain (numeric + boolean):\r\nTypes: rover, location, sample, camera\r\nDescription: \"Rovers navigate locations, collect samples (with mass), and take images. Rovers have fuel.\"\r\n\r\nOutput:\r\n{\r\n  \"types_with_attributes\": [\r\n    {\r\n      \"type_name\": \"rover\",\r\n      \"attributes\": [\r\n        {\"name\": \"rover-at\", \"type\": \"boolean\", \"description\": \"Predicate: (rover-at ?r - rover ?l - location)\"},\r\n        {\"name\": \"fuel\", \"type\": \"numeric\", \"description\": \"Remaining fuel in liters (0-1000)\"},\r\n        {\"name\": \"has-sample\", \"type\": \"boolean\", \"description\": \"Predicate: (has-sample ?r - rover ?s - sample)\"},\r\n        {\"name\": \"equipped-with-camera\", \"type\": \"boolean\", \"description\": \"Predicate: (equipped-with-camera ?r - rover ?c - camera)\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"location\",\r\n      \"attributes\": [\r\n        {\"name\": \"visited\", \"type\": \"boolean\", \"description\": \"True if any rover has been to this location\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"sample\",\r\n      \"attributes\": [\r\n        {\"name\": \"sample-at\", \"type\": \"boolean\", \"description\": \"Predicate: (sample-at ?s - sample ?l - location)\"},\r\n        {\"name\": \"mass\", \"type\": \"numeric\", \"description\": \"Sample mass in grams (1-1000)\"},\r\n        {\"name\": \"analyzed\", \"type\": \"boolean\", \"description\": \"True if sample has been analyzed\"}\r\n      ]\r\n    },\r\n    {\r\n      \"type_name\": \"camera\",\r\n      \"attributes\": [\r\n        {\"name\": \"calibrated\", \"type\": \"boolean\", \"description\": \"True if camera is ready to use\"}\r\n      ]\r\n    }\r\n  ]\r\n}\r\n\r\nExample 4 - Error case to AVOID:\r\n❌ WRONG:\r\n{\"name\": \"on\", \"type\": \"boolean\", \"description\": \"Predicate: (on ?x - (block | table))\"}\r\n\r\n✓ CORRECT:\r\n{\"name\": \"on-table\", \"type\": \"boolean\", \"description\": \"Predicate: (on-table ?b - block)\"}\r\n{\"name\": \"on-block\", \"type\": \"boolean\", \"description\": \"Predicate: (on-block ?b1 - block ?b2 - block)\"}\r\n\r\n---\r\n\r\nNOW PROCESS:\r\n\r\nTypes (JSON):\r\n{{object_types}}\r\n\r\nDomain Description:\r\n{{domain_description}}\r\n\r\nReturn ONLY valid JSON. NO union types. Separate predicates for different type combinations.\r\n\"#\r\n}",
    "extract_goal_azure.baml": "\r\n// Funzione per estrarre il goal\r\nfunction ExtractGoalAzure(\r\n    problem_description: string,\r\n    problem_objects: string,\r\n    initial_state: string,\r\n    domain_description: string\r\n) -> GoalResult {\r\n    client \"CustomAzure\"\r\n    prompt #\"\r\nYou are an expert in formalizing goals in planning problems (PDDL style).\r\n\r\nTASK:\r\nGiven a problem, the objects involved, and the initial state, extract the **goal state (goal)**.\r\nThe goal is the final state that must be Achieved from the initial state.\r\n\r\nA goal consists of:\r\n1. **Conditions** – required final values ​​for specific attributes.\r\n2. **Relations** – required final relationships between objects that must be true.\r\n\r\n---\r\n\r\n### EXAMPLES\r\n\r\n**Example 1**\r\nProblem Description: \"The objective is for plane A1 to reach Milan, and for its fuel level to be at least 50.\"\r\nProblem Objects: A1 (plane), Milan (city)\r\nDomain Attributes: (fuel-level ?a), (at ?o ?l)\r\n\r\nExpected JSON:\r\n{\r\n\"goal_summary\": \"A1 must be in Milan with sufficient fuel.\",\r\n\"conditions\": [\r\n{\"object_name\": \"A1\", \"attribute\": \"fuel-level\", \"required_value\": \">= 50\", \"explanation\": \"Fluent constraint.\"}\r\n],\r\n\"relations\": [ \r\n{\"relation_type\": \"at\", \"object1\": \"A1\", \"object2\": \"Milan\", \"explanation\": \"Target location.\"} \r\n]\r\n}\r\n\r\n**Example 2**\r\nProblem Description: \"Robot R1 must be in room S3. Also, room S1 must not be dirty.\"\r\nProblem Objects: R1 (robot), S3 (room), S1 (room)\r\nDomain Attributes: (is-clean ?s), (at ?o ?l)\r\n\r\nExpected JSON:\r\n{ \r\n\"goal_summary\": \"R1 must move to S3 and S1 must be clean.\", \r\n\"conditions\": [ \r\n{\"object_name\": \"S1\", \"attribute\": \"is-clean\", \"required_value\": \"true\", \"explanation\": \"Room S1 must be clean.\"} \r\n], \r\n\"relations\": [ \r\n{\"relation_type\": \"at\", \"object1\": \"R1\", \"object2\": \"S3\", \"explanation\": \"Robot must reach target location.\"} \r\n]\r\n}\r\n\r\n---\r\n\r\n### DETAILED INSTRUCTIONS\r\n\r\n1. Extract **all explicitly or clearly stated goal conditions and relationships** Implicit.\r\n2. Compare to the initial state: include only what **changes from the initial**.\r\n3. **Conditions** concern final attribute values ​​(boolean, numeric, or location).\r\n4. **Relations** concern relationships between objects (e.g., at, holding, delivered_to).\r\n5. Include everything necessary to consider the problem solved.\r\n6. Be precise and complete, but don't invent non-implicit conditions.\r\n7. Output should be **JSON only**, without additional text or markdown.\r\n\r\n---\r\n\r\n### INPUT\r\n\r\nProblem Description:\r\n---\r\n{{ problem_description }}\r\n---\r\n\r\nProblem Objects:\r\n{{ problem_objects }}\r\n\r\nInitial State:\r\n{{ initial_state }}\r\n\r\nDomain Description:\r\n{{ domain_description }}\r\n\r\n---\r\n\r\n### OUTPUT FORMAT (required)\r\n{ \r\n\"conditions\": [ \r\n{ \r\n\"object_name\": \"med1\", \r\n\"attribute\": \"location\", \r\n\"required_value\": \"wp2\", \r\n\"explanation\": \"Medicine must be delivered to the destination location wp2 where alice is.\" \r\n}, \r\n{ \r\n\"object_name\": \"alice\", \r\n\"attribute\": \"received_medicine\", \r\n\"required_value\": \"true\", \r\n\"explanation\": \"Alice must have received the medicine to complete the delivery.\" \r\n} \r\n], \r\n\"relations\": [ \r\n{ \r\n\"relation_type\": \"delivered_to\", \r\n\"object1\": \"med1\", \r\n\"object2\": \"alice\", \r\n\"explanation\": \"Medicine must be delivered to alice to satisfy the goal.\" \r\n}, \r\n{ \r\n\"relation_type\": \"at\", \r\n\"object1\": \"robby\", \r\n\"object2\": \"wp2\", \r\n\"explanation\": \"Robot must be at destination location after delivery.\" \r\n} \r\n], \r\n\"goal_summary\": \"Deliver medicine med1 to patient alice at location wp2\"\r\n}\r\n\"#\r\n}",
    "extract_goal_deep.baml": "\r\n// Funzione per estrarre il goal\r\nfunction ExtractGoalDeep(\r\n    problem_description: string,\r\n    problem_objects: string,\r\n    initial_state: string,\r\n    domain_description: string\r\n) -> GoalResult {\r\n    client \"CustomDeepSeekCoder\"\r\n    prompt #\"\r\nYou are an expert in formalizing goals in planning problems (PDDL style).\r\n\r\nTASK:\r\nGiven a problem, the objects involved, and the initial state, extract the **goal state (goal)**.\r\nThe goal is the final state that must be Achieved from the initial state.\r\n\r\nA goal consists of:\r\n1. **Conditions** – required final values ​​for specific attributes.\r\n2. **Relations** – required final relationships between objects that must be true.\r\n\r\n---\r\n\r\n### EXAMPLES\r\n\r\n**Example 1**\r\nProblem Description: \"The objective is for plane A1 to reach Milan, and for its fuel level to be at least 50.\"\r\nProblem Objects: A1 (plane), Milan (city)\r\nDomain Attributes: (fuel-level ?a), (at ?o ?l)\r\n\r\nExpected JSON:\r\n{\r\n\"goal_summary\": \"A1 must be in Milan with sufficient fuel.\",\r\n\"conditions\": [\r\n{\"object_name\": \"A1\", \"attribute\": \"fuel-level\", \"required_value\": \">= 50\", \"explanation\": \"Fluent constraint.\"}\r\n],\r\n\"relations\": [ \r\n{\"relation_type\": \"at\", \"object1\": \"A1\", \"object2\": \"Milan\", \"explanation\": \"Target location.\"} \r\n]\r\n}\r\n\r\n**Example 2**\r\nProblem Description: \"Robot R1 must be in room S3. Also, room S1 must not be dirty.\"\r\nProblem Objects: R1 (robot), S3 (room), S1 (room)\r\nDomain Attributes: (is-clean ?s), (at ?o ?l)\r\n\r\nExpected JSON:\r\n{ \r\n\"goal_summary\": \"R1 must move to S3 and S1 must be clean.\", \r\n\"conditions\": [ \r\n{\"object_name\": \"S1\", \"attribute\": \"is-clean\", \"required_value\": \"true\", \"explanation\": \"Room S1 must be clean.\"} \r\n], \r\n\"relations\": [ \r\n{\"relation_type\": \"at\", \"object1\": \"R1\", \"object2\": \"S3\", \"explanation\": \"Robot must reach target location.\"} \r\n]\r\n}\r\n\r\n---\r\n\r\n### DETAILED INSTRUCTIONS\r\n\r\n1. Extract **all explicitly or clearly stated goal conditions and relationships** Implicit.\r\n2. Compare to the initial state: include only what **changes from the initial**.\r\n3. **Conditions** concern final attribute values ​​(boolean, numeric, or location).\r\n4. **Relations** concern relationships between objects (e.g., at, holding, delivered_to).\r\n5. Include everything necessary to consider the problem solved.\r\n6. Be precise and complete, but don't invent non-implicit conditions.\r\n7. Output should be **JSON only**, without additional text or markdown.\r\n\r\n---\r\n\r\n### INPUT\r\n\r\nProblem Description:\r\n---\r\n{{ problem_description }}\r\n---\r\n\r\nProblem Objects:\r\n{{ problem_objects }}\r\n\r\nInitial State:\r\n{{ initial_state }}\r\n\r\nDomain Description:\r\n{{ domain_description }}\r\n\r\n---\r\n\r\n### OUTPUT FORMAT (required)\r\n{ \r\n\"conditions\": [ \r\n{ \r\n\"object_name\": \"med1\", \r\n\"attribute\": \"location\", \r\n\"required_value\": \"wp2\", \r\n\"explanation\": \"Medicine must be delivered to the destination location wp2 where alice is.\" \r\n}, \r\n{ \r\n\"object_name\": \"alice\", \r\n\"attribute\": \"received_medicine\", \r\n\"required_value\": \"true\", \r\n\"explanation\": \"Alice must have received the medicine to complete the delivery.\" \r\n} \r\n], \r\n\"relations\": [ \r\n{ \r\n\"relation_type\": \"delivered_to\", \r\n\"object1\": \"med1\", \r\n\"object2\": \"alice\", \r\n\"explanation\": \"Medicine must be delivered to alice to satisfy the goal.\" \r\n}, \r\n{ \r\n\"relation_type\": \"at\", \r\n\"object1\": \"robby\", \r\n\"object2\": \"wp2\", \r\n\"explanation\": \"Robot must be at destination location after delivery.\" \r\n} \r\n], \r\n\"goal_summary\": \"Deliver medicine med1 to patient alice at location wp2\"\r\n}\r\n\"#\r\n}",
    "extract_goal_gemini.baml": "// Define the class for a goal condition\r\nclass GoalCondition {\r\nobject_name string @description(\"Name of the object involved (e.g., med1, alice, robby)\")\r\nattribute string @description(\"Attribute that must be verified (e.g., delivered, location, loaded)\")\r\nrequired_value string @description(\"Value required to complete the goal (e.g., true, wp2, false)\")\r\nexplanation string? @description(\"Explanation of why this condition is required\")\r\n}\r\n\r\n// Define the class for a goal relationship\r\nclass GoalRelation {\r\nrelation_type string @description(\"Type of goal relationship (e.g., at, holding, delivered_to, equals)\")\r\nobject1 string @description(\"First object involved\")\r\nobject2 string @description(\"Second object involved\")\r\nexplanation string? @description(\"Explanation of why this relationship is required in the goal\")\r\n}\r\n\r\n// Define the main class for the results\r\nclass GoalResult {\r\nconditions GoalCondition[] @description(\"Conditions that must be satisfied to achieve the goal\")\r\nrelations GoalRelation[] @description(\"Relationships between objects that must be true in the goal\")\r\ngoal_summary string @description(\"Brief and concise description of the overall goal\")\r\n}\r\n\r\n// Function to extract the goal\r\nfunction ExtractGoalGemini(\r\nproblem_description: string,\r\nproblem_objects: string,\r\ninitial_state: string,\r\ndomain_description: string\r\n) -> GoalResult {\r\nclient \"CustomGemini\"\r\n prompt #\"\r\nYou are an expert in formalizing goals in planning problems (PDDL style).\r\n\r\nTASK:\r\nGiven a problem, the objects involved, and the initial state, extract the **goal state (goal)**.\r\nThe goal is the final state that must be Achieved from the initial state.\r\n\r\nA goal consists of:\r\n1. **Conditions** – required final values ​​for specific attributes.\r\n2. **Relations** – required final relationships between objects that must be true.\r\n\r\n---\r\n\r\n### EXAMPLES\r\n\r\n**Example 1**\r\nProblem Description: \"The objective is for plane A1 to reach Milan, and for its fuel level to be at least 50.\"\r\nProblem Objects: A1 (plane), Milan (city)\r\nDomain Attributes: (fuel-level ?a), (at ?o ?l)\r\n\r\nExpected JSON:\r\n{\r\n\"goal_summary\": \"A1 must be in Milan with sufficient fuel.\",\r\n\"conditions\": [\r\n{\"object_name\": \"A1\", \"attribute\": \"fuel-level\", \"required_value\": \">= 50\", \"explanation\": \"Fluent constraint.\"}\r\n],\r\n\"relations\": [ \r\n{\"relation_type\": \"at\", \"object1\": \"A1\", \"object2\": \"Milan\", \"explanation\": \"Target location.\"} \r\n]\r\n}\r\n\r\n**Example 2**\r\nProblem Description: \"Robot R1 must be in room S3. Also, room S1 must not be dirty.\"\r\nProblem Objects: R1 (robot), S3 (room), S1 (room)\r\nDomain Attributes: (is-clean ?s), (at ?o ?l)\r\n\r\nExpected JSON:\r\n{ \r\n\"goal_summary\": \"R1 must move to S3 and S1 must be clean.\", \r\n\"conditions\": [ \r\n{\"object_name\": \"S1\", \"attribute\": \"is-clean\", \"required_value\": \"true\", \"explanation\": \"Room S1 must be clean.\"} \r\n], \r\n\"relations\": [ \r\n{\"relation_type\": \"at\", \"object1\": \"R1\", \"object2\": \"S3\", \"explanation\": \"Robot must reach target location.\"} \r\n]\r\n}\r\n\r\n---\r\n\r\n### DETAILED INSTRUCTIONS\r\n\r\n1. Extract **all explicitly or clearly stated goal conditions and relationships** Implicit.\r\n2. Compare to the initial state: include only what **changes from the initial**.\r\n3. **Conditions** concern final attribute values ​​(boolean, numeric, or location).\r\n4. **Relations** concern relationships between objects (e.g., at, holding, delivered_to).\r\n5. Include everything necessary to consider the problem solved.\r\n6. Be precise and complete, but don't invent non-implicit conditions.\r\n7. Output should be **JSON only**, without additional text or markdown.\r\n\r\n---\r\n\r\n### INPUT\r\n\r\nProblem Description:\r\n---\r\n{{ problem_description }}\r\n---\r\n\r\nProblem Objects:\r\n{{ problem_objects }}\r\n\r\nInitial State:\r\n{{ initial_state }}\r\n\r\nDomain Description:\r\n{{ domain_description }}\r\n\r\n---\r\n\r\n### OUTPUT FORMAT (required)\r\n{ \r\n\"conditions\": [ \r\n{ \r\n\"object_name\": \"med1\", \r\n\"attribute\": \"location\", \r\n\"required_value\": \"wp2\", \r\n\"explanation\": \"Medicine must be delivered to the destination location wp2 where alice is.\" \r\n}, \r\n{ \r\n\"object_name\": \"alice\", \r\n\"attribute\": \"received_medicine\", \r\n\"required_value\": \"true\", \r\n\"explanation\": \"Alice must have received the medicine to complete the delivery.\" \r\n} \r\n], \r\n\"relations\": [ \r\n{ \r\n\"relation_type\": \"delivered_to\", \r\n\"object1\": \"med1\", \r\n\"object2\": \"alice\", \r\n\"explanation\": \"Medicine must be delivered to alice to satisfy the goal.\" \r\n}, \r\n{ \r\n\"relation_type\": \"at\", \r\n\"object1\": \"robby\", \r\n\"object2\": \"wp2\", \r\n\"explanation\": \"Robot must be at destination location after delivery.\" \r\n} \r\n], \r\n\"goal_summary\": \"Deliver medicine med1 to patient alice at location wp2\"\r\n}\r\n\"#\r\n}",
    "extract_init_azure.baml": "\r\n// Funzione per estrarre lo stato iniziale\r\nfunction ExtractInitialStateAzure(\r\n    problem_description: string,\r\n    problem_objects: string,\r\n    object_attributes: string,\r\n    domain_description: string\r\n) -> InitialStateResult {\r\n    client \"CustomAzure\"\r\n    prompt #\"\r\nYou are an expert in formalizing initial states in planning problems (PDDL-like).\r\n\r\nTASK:\r\nGiven a problem described in natural language, with its objects, attributes, and domain description,\r\nextract the **initial state** composed of:\r\n1. **Facts** – initial attribute values ​​or fluents for each object.\r\n2. **Relations** – binary or n-ary relations that are true at the initial time (e.g., at, in, connected, holding).\r\n\r\n---\r\n\r\n### EXAMPLES\r\n\r\n**Example 1**\r\nProblem Context:\r\n\"An airplane A1 is in Rome. Its fuel level is 50. Passenger P1 is not on board.\r\n\r\nProblem Objects:\r\nA1 (plane), Rome (city), P1 (person)\r\n\r\nDomain Attributes:\r\n(fuel-level ?a), (on-board ?p), (at ?o ?l)\r\n\r\nExpected Output:\r\n{\r\n\"facts\": [\r\n{\"object_name\": \"A1\", \"attribute\": \"fuel-level\", \"value\": \"50\", \"explanation\": \"The text explicitly indicates the fuel level.\"},\r\n{\"object_name\": \"P1\", \"attribute\": \"on-board\", \"value\": \"false\", \"explanation\": \"The passenger is not on board.\"}\r\n],\r\n\"relations\": [\r\n{\"relation_type\": \"at\", \"object1\": \"A1\", \"object2\": \"Rome\", \"explanation\": \"The plane is located in Rome at the start.\"},\r\n{\"relation_type\": \"at\", \"object1\": \"P1\", \"object2\": \"Rome\", \"explanation\": \"The passenger is initially in the same city.\"}\r\n]\r\n}\r\n\r\n---\r\n\r\n**Example 2**\r\nProblem Context:\r\n\"Robot R1 is in room S1. The room is clean. The robot's battery is charged.\"\r\n\r\nProblem Objects:\r\nR1 (robot), S1 (room)\r\n\r\nDomain Attributes:\r\n(battery-charged ?r), (is-clean ?s), (in ?o ?l)\r\n\r\nExpected Output:\r\n{\r\n\"facts\": [\r\n{\"object_name\": \"R1\", \"attribute\": \"battery-charged\", \"value\": \"true\", \"explanation\": \"The battery is described as charged.\"},\r\n{\"object_name\": \"S1\", \"attribute\": \"is-clean\", \"value\": \"true\", \"explanation\": \"The room is clean at the start.\"}\r\n],\r\n\"relations\": [\r\n{\"relation_type\": \"in\", \"object1\": \"R1\", \"object2\": \"S1\", \"explanation\": \"The robot is inside room S1 initially.\"}\r\n]\r\n}\r\n\r\n---\r\n\r\n###  DETAILED INSTRUCTIONS\r\n\r\n1. Extract **all initial facts** mentioned or clearly implied in the problem.\r\n- If an attribute is numeric (e.g., fuel level, energy), specify the initial value.\r\n- If it is Boolean (e.g., loaded, clean, available), use `true` or `false`.\r\n2. Extract **all relationships** between objects.\r\n- `at(X,Y)` if an object is in a location.\r\n- `holding(X,Y)` if an agent owns something.\r\n- `connected(X,Y)` if two locations are connected.\r\n3. If the text doesn't specify a value but clearly implies one, write a plausible value and explain it in the `explanation`.\r\n4. If an attribute isn't mentioned, **do not invent** superfluous facts or relationships.\r\n5. The initial state must be **consistent and minimal**.\r\n6. The output must contain **only** the JSON, **no additional text or markdown**.\r\n\r\n---\r\n\r\n### 🔹 INPUT\r\n\r\nProblem Description:\r\n---\r\n{{ problem_description }}\r\n---\r\n\r\nProblem Objects:\r\n{{ problem_objects }}\r\n\r\nObject Attributes:\r\n{{ object_attributes }}\r\n\r\nDomain Description:\r\n{{ domain_description }}\r\n\r\n---\r\n\r\n### OUTPUT FORMAT (required)\r\n{ \r\n\"facts\": [ \r\n{ \r\n\"object_name\": \"robby\", \r\n\"attribute\": \"location\", \r\n\"value\": \"wp1\", \r\n\"explanation\": \"The text says that Robby is in wp1.\" \r\n}, \r\n{ \r\n\"object_name\": \"robby\", \r\n\"attribute\": \"loaded\", \r\n\"value\": \"false\", \r\n\"explanation\": \"Robby starts unloaded since he hasn't picked up the package yet.\" \r\n},\r\n{\r\n\"object_name\": \"med1\",\r\n\"attribute\": \"location\",\r\n\"value\": \"wp1\",\r\n\"explanation\": \"The medicine is located in wp1 at the beginning.\"\r\n}\r\n],\r\n\"relations\": [\r\n{\r\n\"relation_type\": \"at\",\r\n\"object1\": \"robby\",\r\n\"object2\": \"wp1\",\r\n\"explanation\": \"Robby is initially at wp1.\"\r\n},\r\n{\r\n\"relation_type\": \"at\",\r\n\"object1\": \"alice\",\r\n\"object2\": \"wp2\",\r\n\"explanation\": \"Alice is initially at wp2.\"\r\n},\r\n{\r\n\"relation_type\": \"available_at\",\r\n\"object1\": \"med1\",\r\n\"object2\": \"wp1\",\r\n\"explanation\": \"The medicine is available at the initial wp1.\"\r\n}\r\n]\r\n}\r\n\"#\r\n}",
    "extract_init_deep.baml": "\r\n// Funzione per estrarre lo stato iniziale\r\nfunction ExtractInitialStateDeep(\r\n    problem_description: string,\r\n    problem_objects: string,\r\n    object_attributes: string,\r\n    domain_description: string\r\n) -> InitialStateResult {\r\n    client \"CustomDeepSeekCoder\"\r\n    prompt #\"\r\nYou are an expert in formalizing initial states in planning problems (PDDL-like).\r\n\r\nTASK:\r\nGiven a problem described in natural language, with its objects, attributes, and domain description,\r\nextract the **initial state** composed of:\r\n1. **Facts** – initial attribute values ​​or fluents for each object.\r\n2. **Relations** – binary or n-ary relations that are true at the initial time (e.g., at, in, connected, holding).\r\n\r\n---\r\n\r\n### EXAMPLES\r\n\r\n**Example 1**\r\nProblem Context:\r\n\"An airplane A1 is in Rome. Its fuel level is 50. Passenger P1 is not on board.\r\n\r\nProblem Objects:\r\nA1 (plane), Rome (city), P1 (person)\r\n\r\nDomain Attributes:\r\n(fuel-level ?a), (on-board ?p), (at ?o ?l)\r\n\r\nExpected Output:\r\n{\r\n\"facts\": [\r\n{\"object_name\": \"A1\", \"attribute\": \"fuel-level\", \"value\": \"50\", \"explanation\": \"The text explicitly indicates the fuel level.\"},\r\n{\"object_name\": \"P1\", \"attribute\": \"on-board\", \"value\": \"false\", \"explanation\": \"The passenger is not on board.\"}\r\n],\r\n\"relations\": [\r\n{\"relation_type\": \"at\", \"object1\": \"A1\", \"object2\": \"Rome\", \"explanation\": \"The plane is located in Rome at the start.\"},\r\n{\"relation_type\": \"at\", \"object1\": \"P1\", \"object2\": \"Rome\", \"explanation\": \"The passenger is initially in the same city.\"}\r\n]\r\n}\r\n\r\n---\r\n\r\n**Example 2**\r\nProblem Context:\r\n\"Robot R1 is in room S1. The room is clean. The robot's battery is charged.\"\r\n\r\nProblem Objects:\r\nR1 (robot), S1 (room)\r\n\r\nDomain Attributes:\r\n(battery-charged ?r), (is-clean ?s), (in ?o ?l)\r\n\r\nExpected Output:\r\n{\r\n\"facts\": [\r\n{\"object_name\": \"R1\", \"attribute\": \"battery-charged\", \"value\": \"true\", \"explanation\": \"The battery is described as charged.\"},\r\n{\"object_name\": \"S1\", \"attribute\": \"is-clean\", \"value\": \"true\", \"explanation\": \"The room is clean at the start.\"}\r\n],\r\n\"relations\": [\r\n{\"relation_type\": \"in\", \"object1\": \"R1\", \"object2\": \"S1\", \"explanation\": \"The robot is inside room S1 initially.\"}\r\n]\r\n}\r\n\r\n---\r\n\r\n###  DETAILED INSTRUCTIONS\r\n\r\n1. Extract **all initial facts** mentioned or clearly implied in the problem.\r\n- If an attribute is numeric (e.g., fuel level, energy), specify the initial value.\r\n- If it is Boolean (e.g., loaded, clean, available), use `true` or `false`.\r\n2. Extract **all relationships** between objects.\r\n- `at(X,Y)` if an object is in a location.\r\n- `holding(X,Y)` if an agent owns something.\r\n- `connected(X,Y)` if two locations are connected.\r\n3. If the text doesn't specify a value but clearly implies one, write a plausible value and explain it in the `explanation`.\r\n4. If an attribute isn't mentioned, **do not invent** superfluous facts or relationships.\r\n5. The initial state must be **consistent and minimal**.\r\n6. The output must contain **only** the JSON, **no additional text or markdown**.\r\n\r\n---\r\n\r\n### 🔹 INPUT\r\n\r\nProblem Description:\r\n---\r\n{{ problem_description }}\r\n---\r\n\r\nProblem Objects:\r\n{{ problem_objects }}\r\n\r\nObject Attributes:\r\n{{ object_attributes }}\r\n\r\nDomain Description:\r\n{{ domain_description }}\r\n\r\n---\r\n\r\n### OUTPUT FORMAT (required)\r\n{ \r\n\"facts\": [ \r\n{ \r\n\"object_name\": \"robby\", \r\n\"attribute\": \"location\", \r\n\"value\": \"wp1\", \r\n\"explanation\": \"The text says that Robby is in wp1.\" \r\n}, \r\n{ \r\n\"object_name\": \"robby\", \r\n\"attribute\": \"loaded\", \r\n\"value\": \"false\", \r\n\"explanation\": \"Robby starts unloaded since he hasn't picked up the package yet.\" \r\n},\r\n{\r\n\"object_name\": \"med1\",\r\n\"attribute\": \"location\",\r\n\"value\": \"wp1\",\r\n\"explanation\": \"The medicine is located in wp1 at the beginning.\"\r\n}\r\n],\r\n\"relations\": [\r\n{\r\n\"relation_type\": \"at\",\r\n\"object1\": \"robby\",\r\n\"object2\": \"wp1\",\r\n\"explanation\": \"Robby is initially at wp1.\"\r\n},\r\n{\r\n\"relation_type\": \"at\",\r\n\"object1\": \"alice\",\r\n\"object2\": \"wp2\",\r\n\"explanation\": \"Alice is initially at wp2.\"\r\n},\r\n{\r\n\"relation_type\": \"available_at\",\r\n\"object1\": \"med1\",\r\n\"object2\": \"wp1\",\r\n\"explanation\": \"The medicine is available at the initial wp1.\"\r\n}\r\n]\r\n}\r\n\"#\r\n}",
    "extract_init_gemini.baml": "// Define the class for an initial fact (attribute-value)\r\nclass InitialFact {\r\nobject_name string @description(\"Name of the object (e.g., robby, package_a, room1)\")\r\nattribute string @description(\"Attribute or fluent of the object (e.g., location, loaded, battery)\")\r\nvalue string @description(\"Value of the attribute at the beginning (e.g., wp1, true, 100)\")\r\nexplanation string? @description(\"Brief explanation of why this initial value is set\")\r\n}\r\n\r\n// Define the class for an initial relationship\r\nclass InitialRelation {\r\nrelation_type string @description(\"Type of relationship (e.g., at, in, holding, connected_to)\")\r\nobject1 string @description(\"First object involved in the relationship\")\r\nobject2 string @description(\"Second object involved in the relationship\")\r\nexplanation string? @description(\"Brief motivation or reference to the problem text\")\r\n}\r\n\r\n// Define the main class for the results\r\nclass InitialStateResult {\r\nfacts InitialFact[] @description(\"List of initial facts (atomic states or attribute values)\")\r\nrelations InitialRelation[] @description(\"List of initial relations between objects\")\r\n}\r\n\r\n// Function to extract the initial state\r\nfunction ExtractInitialStateGemini(\r\nproblem_description: string,\r\nproblem_objects: string,\r\nobject_attributes: string,\r\ndomain_description: string\r\n) -> InitialStateResult {\r\nclient \"CustomGemini\"\r\n    prompt #\"\r\nYou are an expert in formalizing initial states in planning problems (PDDL-like).\r\n\r\nTASK:\r\nGiven a problem described in natural language, with its objects, attributes, and domain description,\r\nextract the **initial state** composed of:\r\n1. **Facts** – initial attribute values ​​or fluents for each object.\r\n2. **Relations** – binary or n-ary relations that are true at the initial time (e.g., at, in, connected, holding).\r\n\r\n---\r\n\r\n### EXAMPLES\r\n\r\n**Example 1**\r\nProblem Context:\r\n\"An airplane A1 is in Rome. Its fuel level is 50. Passenger P1 is not on board.\r\n\r\nProblem Objects:\r\nA1 (plane), Rome (city), P1 (person)\r\n\r\nDomain Attributes:\r\n(fuel-level ?a), (on-board ?p), (at ?o ?l)\r\n\r\nExpected Output:\r\n{\r\n\"facts\": [\r\n{\"object_name\": \"A1\", \"attribute\": \"fuel-level\", \"value\": \"50\", \"explanation\": \"The text explicitly indicates the fuel level.\"},\r\n{\"object_name\": \"P1\", \"attribute\": \"on-board\", \"value\": \"false\", \"explanation\": \"The passenger is not on board.\"}\r\n],\r\n\"relations\": [\r\n{\"relation_type\": \"at\", \"object1\": \"A1\", \"object2\": \"Rome\", \"explanation\": \"The plane is located in Rome at the start.\"},\r\n{\"relation_type\": \"at\", \"object1\": \"P1\", \"object2\": \"Rome\", \"explanation\": \"The passenger is initially in the same city.\"}\r\n]\r\n}\r\n\r\n---\r\n\r\n**Example 2**\r\nProblem Context:\r\n\"Robot R1 is in room S1. The room is clean. The robot's battery is charged.\"\r\n\r\nProblem Objects:\r\nR1 (robot), S1 (room)\r\n\r\nDomain Attributes:\r\n(battery-charged ?r), (is-clean ?s), (in ?o ?l)\r\n\r\nExpected Output:\r\n{\r\n\"facts\": [\r\n{\"object_name\": \"R1\", \"attribute\": \"battery-charged\", \"value\": \"true\", \"explanation\": \"The battery is described as charged.\"},\r\n{\"object_name\": \"S1\", \"attribute\": \"is-clean\", \"value\": \"true\", \"explanation\": \"The room is clean at the start.\"}\r\n],\r\n\"relations\": [\r\n{\"relation_type\": \"in\", \"object1\": \"R1\", \"object2\": \"S1\", \"explanation\": \"The robot is inside room S1 initially.\"}\r\n]\r\n}\r\n\r\n---\r\n\r\n###  DETAILED INSTRUCTIONS\r\n\r\n1. Extract **all initial facts** mentioned or clearly implied in the problem.\r\n- If an attribute is numeric (e.g., fuel level, energy), specify the initial value.\r\n- If it is Boolean (e.g., loaded, clean, available), use `true` or `false`.\r\n2. Extract **all relationships** between objects.\r\n- `at(X,Y)` if an object is in a location.\r\n- `holding(X,Y)` if an agent owns something.\r\n- `connected(X,Y)` if two locations are connected.\r\n3. If the text doesn't specify a value but clearly implies one, write a plausible value and explain it in the `explanation`.\r\n4. If an attribute isn't mentioned, **do not invent** superfluous facts or relationships.\r\n5. The initial state must be **consistent and minimal**.\r\n6. The output must contain **only** the JSON, **no additional text or markdown**.\r\n\r\n---\r\n\r\n### 🔹 INPUT\r\n\r\nProblem Description:\r\n---\r\n{{ problem_description }}\r\n---\r\n\r\nProblem Objects:\r\n{{ problem_objects }}\r\n\r\nObject Attributes:\r\n{{ object_attributes }}\r\n\r\nDomain Description:\r\n{{ domain_description }}\r\n\r\n---\r\n\r\n### OUTPUT FORMAT (required)\r\n{ \r\n\"facts\": [ \r\n{ \r\n\"object_name\": \"robby\", \r\n\"attribute\": \"location\", \r\n\"value\": \"wp1\", \r\n\"explanation\": \"The text says that Robby is in wp1.\" \r\n}, \r\n{ \r\n\"object_name\": \"robby\", \r\n\"attribute\": \"loaded\", \r\n\"value\": \"false\", \r\n\"explanation\": \"Robby starts unloaded since he hasn't picked up the package yet.\" \r\n},\r\n{\r\n\"object_name\": \"med1\",\r\n\"attribute\": \"location\",\r\n\"value\": \"wp1\",\r\n\"explanation\": \"The medicine is located in wp1 at the beginning.\"\r\n}\r\n],\r\n\"relations\": [\r\n{\r\n\"relation_type\": \"at\",\r\n\"object1\": \"robby\",\r\n\"object2\": \"wp1\",\r\n\"explanation\": \"Robby is initially at wp1.\"\r\n},\r\n{\r\n\"relation_type\": \"at\",\r\n\"object1\": \"alice\",\r\n\"object2\": \"wp2\",\r\n\"explanation\": \"Alice is initially at wp2.\"\r\n},\r\n{\r\n\"relation_type\": \"available_at\",\r\n\"object1\": \"med1\",\r\n\"object2\": \"wp1\",\r\n\"explanation\": \"The medicine is available at the initial wp1.\"\r\n}\r\n]\r\n}\r\n\"#\r\n}",
    "extract_object_azure.baml": "\r\n// Funzione per estrarre gli oggetti dal problema\r\nfunction ExtractProblemObjectsAzure(\r\n    problem_description: string,\r\n    object_types: string,\r\n    domain_description: string\r\n) -> ObjectsResult {\r\n    client \"CustomAzure\"\r\n    prompt #\"\r\nYou are an expert at identifying objects/instances for planning problems (PDDL style).\r\n\r\nTask: Given the problem description text (`{{ problem_description }}`), the list of object types available in the domain (`{{ object_types }}`), and the domain description (`{{ domain_description }}`), extract **all** instances (objects) mentioned in the problem. For each object, provide: `name`, `type` (one of the domain types), and a very short `description` explaining the instance's role in the problem.\r\n\r\nIMPORTANT RULES\r\n1. Extract **EVERY** object explicitly mentioned in the problem (agents, items, locations, waypoints, etc.).\r\n2. Match each object to the correct **type** among those in `{{ object_types }}`. Use the domain context (`{{ domain_description }}`) to resolve ambiguities.\r\n3. If the problem uses names that clearly indicate the type (e.g., \"Robby\" for robot, \"Pkg1\" for package), map them directly.\r\n4. If a name is ambiguous but the domain suggests the type, choose the most consistent type and explain it briefly in the `description`.\r\n5. Also include objects that are locations (room, waypoint, city, depot) and resources (medicine, battery station) if mentioned.\r\n6. Do not add objects not present in the problem text (no invented ones) unless they are **explicitly implied** and necessary: ​​in that case, include them only if strictly justified in the `description`.\r\n7. `name` must be the exact token as it appears in the problem (case sensitive if used).\r\n8. `description` must be short (1 sentence) and indicate the object's role in the problem.\r\n9. **Output**: Return ONLY the JSON object that begins with `{` and ends with `}`, following the pattern shown exactly. NO additional text, NO markdown.\r\n\r\nEXAMPLES (INPUT → OUTPUT)\r\n\r\nExample 1:\r\nDomain Types: airplane, person, city\r\nDomain Description: (domain flight)\r\nProblem Description: \"A plane A1, of type airplane, is at the Rome airport. A passenger P1 is on board.\"\r\n\r\nExpected JSON:\r\n{ \r\n\"objects\": [ \r\n{\"name\": \"A1\", \"type\": \"airplane\", \"description\": \"The aircraft involved in the problem.\"}, \r\n{\"name\": \"Rome\", \"type\": \"city\", \"description\": \"Aircraft departure city.\"}, \r\n{\"name\": \"P1\", \"type\": \"person\", \"description\": \"Passenger on board the plane.\"} \r\n]\r\n}\r\n\r\nExample 2:\r\nDomain Types: robot, package, room\r\nDomain Description: (delivery domain)\r\nProblem Description: \"The robot Robby is in RoomA. Must take Pkg1 and bring it to RoomB.\"\r\n\r\nExpected JSON:\r\n{\r\n\"objects\": [\r\n{\"name\": \"Robby\", \"type\": \"robot\", \"description\": \"Agent that should perform the actions.\"},\r\n{\"name\": \"Pkg1\", \"type\": \"package\", \"description\": \"Package to be delivered.\"},\r\n{\"name\": \"RoomA\", \"type\": \"room\", \"description\": \"Robot's starting position.\"},\r\n{\"name\": \"RoomB\", \"type\": \"room\", \"description\": \"Destination of the package.\"}\r\n]\r\n}\r\n\r\nNOW PROCESS ON THE PROVIDED INPUT:\r\n\r\nDomain Object Types:\r\n{{ object_types }}\r\n\r\nDomain Description:\r\n{{ domain_description }}\r\n\r\nProblem Description:\r\n---\r\n{{ problem_description }}\r\n---\r\n\r\nREMEMBER: Return ONLY the JSON in this exact format:\r\n\r\n{\r\n\"objects\": [\r\n{\r\n\"name\": \"instance_name\",\r\n\"type\": \"domain_type\",\r\n\"description\": \"brief description of the instance's role in the problem\"\r\n}\r\n]\r\n}\r\n\"#\r\n}",
    "extract_object_deep.baml": "\r\n// Funzione per estrarre gli oggetti dal problema\r\nfunction ExtractProblemObjectsDeep(\r\n    problem_description: string,\r\n    object_types: string,\r\n    domain_description: string\r\n) -> ObjectsResult {\r\n    client \"CustomDeepSeekCoder\"\r\n    prompt #\"\r\nYou are an expert at identifying objects/instances for planning problems (PDDL style).\r\n\r\nTask: Given the problem description text (`{{ problem_description }}`), the list of object types available in the domain (`{{ object_types }}`), and the domain description (`{{ domain_description }}`), extract **all** instances (objects) mentioned in the problem. For each object, provide: `name`, `type` (one of the domain types), and a very short `description` explaining the instance's role in the problem.\r\n\r\nIMPORTANT RULES\r\n1. Extract **EVERY** object explicitly mentioned in the problem (agents, items, locations, waypoints, etc.).\r\n2. Match each object to the correct **type** among those in `{{ object_types }}`. Use the domain context (`{{ domain_description }}`) to resolve ambiguities.\r\n3. If the problem uses names that clearly indicate the type (e.g., \"Robby\" for robot, \"Pkg1\" for package), map them directly.\r\n4. If a name is ambiguous but the domain suggests the type, choose the most consistent type and explain it briefly in the `description`.\r\n5. Also include objects that are locations (room, waypoint, city, depot) and resources (medicine, battery station) if mentioned.\r\n6. Do not add objects not present in the problem text (no invented ones) unless they are **explicitly implied** and necessary: ​​in that case, include them only if strictly justified in the `description`.\r\n7. `name` must be the exact token as it appears in the problem (case sensitive if used).\r\n8. `description` must be short (1 sentence) and indicate the object's role in the problem.\r\n9. **Output**: Return ONLY the JSON object that begins with `{` and ends with `}`, following the pattern shown exactly. NO additional text, NO markdown.\r\n\r\nEXAMPLES (INPUT → OUTPUT)\r\n\r\nExample 1:\r\nDomain Types: airplane, person, city\r\nDomain Description: (domain flight)\r\nProblem Description: \"A plane A1, of type airplane, is at the Rome airport. A passenger P1 is on board.\"\r\n\r\nExpected JSON:\r\n{ \r\n\"objects\": [ \r\n{\"name\": \"A1\", \"type\": \"airplane\", \"description\": \"The aircraft involved in the problem.\"}, \r\n{\"name\": \"Rome\", \"type\": \"city\", \"description\": \"Aircraft departure city.\"}, \r\n{\"name\": \"P1\", \"type\": \"person\", \"description\": \"Passenger on board the plane.\"} \r\n]\r\n}\r\n\r\nExample 2:\r\nDomain Types: robot, package, room\r\nDomain Description: (delivery domain)\r\nProblem Description: \"The robot Robby is in RoomA. Must take Pkg1 and bring it to RoomB.\"\r\n\r\nExpected JSON:\r\n{\r\n\"objects\": [\r\n{\"name\": \"Robby\", \"type\": \"robot\", \"description\": \"Agent that should perform the actions.\"},\r\n{\"name\": \"Pkg1\", \"type\": \"package\", \"description\": \"Package to be delivered.\"},\r\n{\"name\": \"RoomA\", \"type\": \"room\", \"description\": \"Robot's starting position.\"},\r\n{\"name\": \"RoomB\", \"type\": \"room\", \"description\": \"Destination of the package.\"}\r\n]\r\n}\r\n\r\nNOW PROCESS ON THE PROVIDED INPUT:\r\n\r\nDomain Object Types:\r\n{{ object_types }}\r\n\r\nDomain Description:\r\n{{ domain_description }}\r\n\r\nProblem Description:\r\n---\r\n{{ problem_description }}\r\n---\r\n\r\nREMEMBER: Return ONLY the JSON in this exact format:\r\n\r\n{\r\n\"objects\": [\r\n{\r\n\"name\": \"instance_name\",\r\n\"type\": \"domain_type\",\r\n\"description\": \"brief description of the instance's role in the problem\"\r\n}\r\n]\r\n}\r\n\"#\r\n}",
    "extract_object_gemini.baml": "// Definisci la classe per un oggetto singolo\r\nclass ProblemObject {\r\n    name string @description(\"Nome dell'oggetto (es: robby, alice, med1, wp1)\")\r\n    type string @description(\"Tipo dell'oggetto (es: robot, patient, medicine, waypoint)\")\r\n    description string? @description(\"Descrizione breve dell'oggetto e il suo ruolo nel problema\")\r\n}\r\n\r\n// Definisci la classe principale per i risultati\r\nclass ObjectsResult {\r\n    objects ProblemObject[] @description(\"Lista di tutti gli oggetti presenti nel problema\")\r\n}\r\n\r\n// Funzione per estrarre gli oggetti dal problema\r\nfunction ExtractProblemObjectsGemini(\r\n    problem_description: string,\r\n    object_types: string,\r\n    domain_description: string\r\n) -> ObjectsResult {\r\n    client \"CustomGemini\"\r\n    prompt #\"\r\nYou are an expert at identifying objects/instances for planning problems (PDDL style).\r\n\r\nTask: Given the problem description text (`{{ problem_description }}`), extact the list of object types available in the domain (`{{ object_types }}`), and the domain description (`{{ domain_description }}`), extract **all** instances (objects) mentioned in the problem. For each object, provide: `name`, `type` (one of the domain types), and a very short `description` explaining the instance's role in the problem.\r\n\r\nIMPORTANT RULES\r\n1. Extract **EVERY** object explicitly mentioned in the problem (agents, items, locations, waypoints, etc.).\r\n2. Match each object to the correct **type** among those in `{{ object_types }}`. Use the domain context (`{{ domain_description }}`) to resolve ambiguities.\r\n3. If the problem uses names that clearly indicate the type (e.g., \"Robby\" for robot, \"Pkg1\" for package), map them directly.\r\n4. If a name is ambiguous but the domain suggests the type, choose the most consistent type and explain it briefly in the `description`.\r\n5. Also include objects that are locations (room, waypoint, city, depot) and resources (medicine, battery station) if mentioned.\r\n6. Do not add objects not present in the problem text (no invented ones) unless they are **explicitly implied** and necessary: ​​in that case, include them only if strictly justified in the `description`.\r\n7. `name` must be the exact token as it appears in the problem (case sensitive if used).\r\n8. `description` must be short (1 sentence) and indicate the object's role in the problem.\r\n9. **Output**: Return ONLY the JSON object that begins with `{` and ends with `}`, following the pattern shown exactly. NO additional text, NO markdown.\r\n\r\nEXAMPLES (INPUT → OUTPUT)\r\n\r\nExample 1:\r\nDomain Types: airplane, person, city\r\nDomain Description: (domain flight)\r\nProblem Description: \"A plane A1, of type airplane, is at the Rome airport. A passenger P1 is on board.\"\r\n\r\nExpected JSON:\r\n{ \r\n\"objects\": [ \r\n{\"name\": \"A1\", \"type\": \"airplane\", \"description\": \"The aircraft involved in the problem.\"}, \r\n{\"name\": \"Rome\", \"type\": \"city\", \"description\": \"Aircraft departure city.\"}, \r\n{\"name\": \"P1\", \"type\": \"person\", \"description\": \"Passenger on board the plane.\"} \r\n]\r\n}\r\n\r\nExample 2:\r\nDomain Types: robot, package, room\r\nDomain Description: (delivery domain)\r\nProblem Description: \"The robot Robby is in RoomA. Must take Pkg1 and bring it to RoomB.\"\r\n\r\nExpected JSON:\r\n{\r\n\"objects\": [\r\n{\"name\": \"Robby\", \"type\": \"robot\", \"description\": \"Agent that should perform the actions.\"},\r\n{\"name\": \"Pkg1\", \"type\": \"package\", \"description\": \"Package to be delivered.\"},\r\n{\"name\": \"RoomA\", \"type\": \"room\", \"description\": \"Robot's starting position.\"},\r\n{\"name\": \"RoomB\", \"type\": \"room\", \"description\": \"Destination of the package.\"}\r\n]\r\n}\r\n\r\nNOW PROCESS ON THE PROVIDED INPUT:\r\n\r\nDomain Object Types:\r\n{{ object_types }}\r\n\r\nDomain Description:\r\n{{ domain_description }}\r\n\r\nProblem Description:\r\n---\r\n{{ problem_description }}\r\n---\r\n\r\nREMEMBER: Return ONLY the JSON in this exact format:\r\n\r\n{\r\n\"objects\": [\r\n{\r\n\"name\": \"instance_name\",\r\n\"type\": \"domain_type\",\r\n\"description\": \"brief description of the instance's role in the problem\"\r\n}\r\n]\r\n}\r\n\"#\r\n}",
    "extract_types_azure.baml": "// Funzione per estrarre i tipi di oggetti\r\nfunction ExtractObjectTypesAzure(domain_description: string) -> ObjectTypesResult {\r\n    client \"CustomAzure\"\r\n    prompt #\"\r\nYou are an expert in PDDL domain modeling and type extraction.\r\n\r\nTASK: Extract ALL object types from the domain description, including their hierarchical relationships.\r\n\r\nCRITICAL RULES:\r\n1. Extract EVERY distinct entity type mentioned (nouns representing classes of objects)\r\n2. Identify parent-child relationships (e.g., \"truck is a vehicle\")\r\n3. If no parent exists, set parent_type to null\r\n4. Use lowercase, hyphenated names (e.g., \"delivery-robot\", not \"DeliveryRobot\")\r\n5. Create descriptions that capture the PURPOSE of each type in planning\r\n6. If the description mentions abstract categories (e.g., \"vehicles\"), extract them even if not explicitly used\r\n7. Handle implicit hierarchies (e.g., \"robots and drones\" → both could be \"agent\" subtypes)\r\n\r\nVALIDATION CHECKS:\r\n- No cycles in hierarchy (a type cannot be its own ancestor)\r\n- Parent types must be defined or be 'object'\r\n- No duplicate type names\r\n- Names must match regex: ^[a-z][a-z0-9-]*$\r\n\r\nEXAMPLES:\r\n\r\nExample 1 - Simple flat types:\r\nInput: \"There are robots, packages, and locations. Robots move and carry packages.\"\r\nOutput:\r\n{\r\n  \"types\": [\r\n    {\"name\": \"robot\", \"parent_type\": null, \"description\": \"Mobile agent that transports items\"},\r\n    {\"name\": \"package\", \"parent_type\": null, \"description\": \"Object that can be transported\"},\r\n    {\"name\": \"location\", \"parent_type\": null, \"description\": \"Physical position in the environment\"}\r\n  ]\r\n}\r\n\r\nExample 2 - Complex hierarchy:\r\nInput: \"Vehicles include trucks and airplanes. Trucks are ground vehicles, airplanes are aerial vehicles. Both transport cargo.\"\r\nOutput:\r\n{\r\n  \"types\": [\r\n    {\"name\": \"vehicle\", \"parent_type\": null, \"description\": \"General transport entity\"},\r\n    {\"name\": \"ground-vehicle\", \"parent_type\": \"vehicle\", \"description\": \"Vehicle that operates on land\"},\r\n    {\"name\": \"aerial-vehicle\", \"parent_type\": \"vehicle\", \"description\": \"Vehicle that operates in air\"},\r\n    {\"name\": \"truck\", \"parent_type\": \"ground-vehicle\", \"description\": \"Ground vehicle for cargo transport\"},\r\n    {\"name\": \"airplane\", \"parent_type\": \"aerial-vehicle\", \"description\": \"Aerial vehicle for cargo transport\"},\r\n    {\"name\": \"cargo\", \"parent_type\": null, \"description\": \"Goods being transported\"}\r\n  ]\r\n}\r\n\r\nExample 3 - Implicit types:\r\nInput: \"Agents navigate a grid world with obstacles. Some cells contain items.\"\r\nOutput:\r\n{\r\n  \"types\": [\r\n    {\"name\": \"agent\", \"parent_type\": null, \"description\": \"Entity that can navigate and interact\"},\r\n    {\"name\": \"cell\", \"parent_type\": null, \"description\": \"Single position in the grid\"},\r\n    {\"name\": \"obstacle\", \"parent_type\": null, \"description\": \"Blocking object in the environment\"},\r\n    {\"name\": \"item\", \"parent_type\": null, \"description\": \"Object that can be collected or manipulated\"}\r\n  ]\r\n}\r\n\r\nExample 4 - Domain with roles:\r\nInput: \"Players, goalies, and referees are on the field. Players and goalies are team members.\"\r\nOutput:\r\n{\r\n  \"types\": [\r\n    {\"name\": \"person\", \"parent_type\": null, \"description\": \"Human participant in the game\"},\r\n    {\"name\": \"team-member\", \"parent_type\": \"person\", \"description\": \"Person belonging to a team\"},\r\n    {\"name\": \"player\", \"parent_type\": \"team-member\", \"description\": \"Team member who plays the game\"},\r\n    {\"name\": \"goalie\", \"parent_type\": \"team-member\", \"description\": \"Team member who defends the goal\"},\r\n    {\"name\": \"referee\", \"parent_type\": \"person\", \"description\": \"Official who enforces rules\"},\r\n    {\"name\": \"field\", \"parent_type\": null, \"description\": \"Playing area\"}\r\n  ]\r\n}\r\n\r\n---\r\n\r\nNOW PROCESS THIS DOMAIN:\r\n\r\n{{domain_description}}\r\n\r\nReturn ONLY valid JSON matching the schema. No markdown, no explanations.\r\n\"#\r\n}",
    "extract_types_deep.baml": "// Funzione per estrarre i tipi di oggetti\r\nfunction ExtractObjectTypesDeep(domain_description: string) -> ObjectTypesResult {\r\n    client \"CustomDeepSeekCoder\"\r\n    prompt #\"\r\nYou are an expert in PDDL domain modeling and type extraction.\r\n\r\nTASK: Extract ALL object types from the domain description, including their hierarchical relationships.\r\n\r\nCRITICAL RULES:\r\n1. Extract EVERY distinct entity type mentioned (nouns representing classes of objects)\r\n2. Identify parent-child relationships (e.g., \"truck is a vehicle\")\r\n3. If no parent exists, set parent_type to null\r\n4. Use lowercase, hyphenated names (e.g., \"delivery-robot\", not \"DeliveryRobot\")\r\n5. Create descriptions that capture the PURPOSE of each type in planning\r\n6. If the description mentions abstract categories (e.g., \"vehicles\"), extract them even if not explicitly used\r\n7. Handle implicit hierarchies (e.g., \"robots and drones\" → both could be \"agent\" subtypes)\r\n\r\nVALIDATION CHECKS:\r\n- No cycles in hierarchy (a type cannot be its own ancestor)\r\n- Parent types must be defined or be 'object'\r\n- No duplicate type names\r\n- Names must match regex: ^[a-z][a-z0-9-]*$\r\n\r\nEXAMPLES:\r\n\r\nExample 1 - Simple flat types:\r\nInput: \"There are robots, packages, and locations. Robots move and carry packages.\"\r\nOutput:\r\n{\r\n  \"types\": [\r\n    {\"name\": \"robot\", \"parent_type\": null, \"description\": \"Mobile agent that transports items\"},\r\n    {\"name\": \"package\", \"parent_type\": null, \"description\": \"Object that can be transported\"},\r\n    {\"name\": \"location\", \"parent_type\": null, \"description\": \"Physical position in the environment\"}\r\n  ]\r\n}\r\n\r\nExample 2 - Complex hierarchy:\r\nInput: \"Vehicles include trucks and airplanes. Trucks are ground vehicles, airplanes are aerial vehicles. Both transport cargo.\"\r\nOutput:\r\n{\r\n  \"types\": [\r\n    {\"name\": \"vehicle\", \"parent_type\": null, \"description\": \"General transport entity\"},\r\n    {\"name\": \"ground-vehicle\", \"parent_type\": \"vehicle\", \"description\": \"Vehicle that operates on land\"},\r\n    {\"name\": \"aerial-vehicle\", \"parent_type\": \"vehicle\", \"description\": \"Vehicle that operates in air\"},\r\n    {\"name\": \"truck\", \"parent_type\": \"ground-vehicle\", \"description\": \"Ground vehicle for cargo transport\"},\r\n    {\"name\": \"airplane\", \"parent_type\": \"aerial-vehicle\", \"description\": \"Aerial vehicle for cargo transport\"},\r\n    {\"name\": \"cargo\", \"parent_type\": null, \"description\": \"Goods being transported\"}\r\n  ]\r\n}\r\n\r\nExample 3 - Implicit types:\r\nInput: \"Agents navigate a grid world with obstacles. Some cells contain items.\"\r\nOutput:\r\n{\r\n  \"types\": [\r\n    {\"name\": \"agent\", \"parent_type\": null, \"description\": \"Entity that can navigate and interact\"},\r\n    {\"name\": \"cell\", \"parent_type\": null, \"description\": \"Single position in the grid\"},\r\n    {\"name\": \"obstacle\", \"parent_type\": null, \"description\": \"Blocking object in the environment\"},\r\n    {\"name\": \"item\", \"parent_type\": null, \"description\": \"Object that can be collected or manipulated\"}\r\n  ]\r\n}\r\n\r\nExample 4 - Domain with roles:\r\nInput: \"Players, goalies, and referees are on the field. Players and goalies are team members.\"\r\nOutput:\r\n{\r\n  \"types\": [\r\n    {\"name\": \"person\", \"parent_type\": null, \"description\": \"Human participant in the game\"},\r\n    {\"name\": \"team-member\", \"parent_type\": \"person\", \"description\": \"Person belonging to a team\"},\r\n    {\"name\": \"player\", \"parent_type\": \"team-member\", \"description\": \"Team member who plays the game\"},\r\n    {\"name\": \"goalie\", \"parent_type\": \"team-member\", \"description\": \"Team member who defends the goal\"},\r\n    {\"name\": \"referee\", \"parent_type\": \"person\", \"description\": \"Official who enforces rules\"},\r\n    {\"name\": \"field\", \"parent_type\": null, \"description\": \"Playing area\"}\r\n  ]\r\n}\r\n\r\n---\r\n\r\nNOW PROCESS THIS DOMAIN:\r\n\r\n{{domain_description}}\r\n\r\nReturn ONLY valid JSON matching the schema. No markdown, no explanations.\r\n\"#\r\n}",
    "extract_types_gemini.baml": "// Definisci la classe per la gerarchia\r\nclass ObjectTypeHierarchy {\r\n    name string @description(\"Nome del tipo di oggetto (es: robot, agent, package)\")\r\n    parent_type string? @description(\"Tipo genitore se esiste una gerarchia, altrimenti null\")\r\n    description string? @description(\"Breve descrizione del tipo (1-2 righe)\")\r\n}\r\n\r\n// Definisci la classe principale per i risultati\r\nclass ObjectTypesResult {\r\n    types ObjectTypeHierarchy[] @description(\"Lista di tutti i tipi di oggetti con le loro gerarchie\")\r\n}\r\n\r\n// Funzione per estrarre i tipi di oggetti\r\nfunction ExtractObjectTypesGemini(domain_description: string) -> ObjectTypesResult {\r\n    client \"CustomGemini\"\r\n    prompt #\"\r\nYou are an expert in PDDL domain modeling and type extraction.\r\n\r\nTASK: Extract ALL object types from the domain description, including their hierarchical relationships.\r\n\r\nCRITICAL RULES:\r\n1. Extract EVERY distinct entity type mentioned (nouns representing classes of objects)\r\n2. Identify parent-child relationships (e.g., \"truck is a vehicle\")\r\n3. If no parent exists, set parent_type to null\r\n4. Use lowercase, hyphenated names (e.g., \"delivery-robot\", not \"DeliveryRobot\")\r\n5. Create descriptions that capture the PURPOSE of each type in planning\r\n6. If the description mentions abstract categories (e.g., \"vehicles\"), extract them even if not explicitly used\r\n7. Handle implicit hierarchies (e.g., \"robots and drones\" → both could be \"agent\" subtypes)\r\n\r\nVALIDATION CHECKS:\r\n- No cycles in hierarchy (a type cannot be its own ancestor)\r\n- Parent types must be defined or be 'object'\r\n- No duplicate type names\r\n- Names must match regex: ^[a-z][a-z0-9-]*$\r\n\r\nEXAMPLES:\r\n\r\nExample 1 - Simple flat types:\r\nInput: \"There are robots, packages, and locations. Robots move and carry packages.\"\r\nOutput:\r\n{\r\n  \"types\": [\r\n    {\"name\": \"robot\", \"parent_type\": null, \"description\": \"Mobile agent that transports items\"},\r\n    {\"name\": \"package\", \"parent_type\": null, \"description\": \"Object that can be transported\"},\r\n    {\"name\": \"location\", \"parent_type\": null, \"description\": \"Physical position in the environment\"}\r\n  ]\r\n}\r\n\r\nExample 2 - Complex hierarchy:\r\nInput: \"Vehicles include trucks and airplanes. Trucks are ground vehicles, airplanes are aerial vehicles. Both transport cargo.\"\r\nOutput:\r\n{\r\n  \"types\": [\r\n    {\"name\": \"vehicle\", \"parent_type\": null, \"description\": \"General transport entity\"},\r\n    {\"name\": \"ground-vehicle\", \"parent_type\": \"vehicle\", \"description\": \"Vehicle that operates on land\"},\r\n    {\"name\": \"aerial-vehicle\", \"parent_type\": \"vehicle\", \"description\": \"Vehicle that operates in air\"},\r\n    {\"name\": \"truck\", \"parent_type\": \"ground-vehicle\", \"description\": \"Ground vehicle for cargo transport\"},\r\n    {\"name\": \"airplane\", \"parent_type\": \"aerial-vehicle\", \"description\": \"Aerial vehicle for cargo transport\"},\r\n    {\"name\": \"cargo\", \"parent_type\": null, \"description\": \"Goods being transported\"}\r\n  ]\r\n}\r\n\r\nExample 3 - Implicit types:\r\nInput: \"Agents navigate a grid world with obstacles. Some cells contain items.\"\r\nOutput:\r\n{\r\n  \"types\": [\r\n    {\"name\": \"agent\", \"parent_type\": null, \"description\": \"Entity that can navigate and interact\"},\r\n    {\"name\": \"cell\", \"parent_type\": null, \"description\": \"Single position in the grid\"},\r\n    {\"name\": \"obstacle\", \"parent_type\": null, \"description\": \"Blocking object in the environment\"},\r\n    {\"name\": \"item\", \"parent_type\": null, \"description\": \"Object that can be collected or manipulated\"}\r\n  ]\r\n}\r\n\r\nExample 4 - Domain with roles:\r\nInput: \"Players, goalies, and referees are on the field. Players and goalies are team members.\"\r\nOutput:\r\n{\r\n  \"types\": [\r\n    {\"name\": \"person\", \"parent_type\": null, \"description\": \"Human participant in the game\"},\r\n    {\"name\": \"team-member\", \"parent_type\": \"person\", \"description\": \"Person belonging to a team\"},\r\n    {\"name\": \"player\", \"parent_type\": \"team-member\", \"description\": \"Team member who plays the game\"},\r\n    {\"name\": \"goalie\", \"parent_type\": \"team-member\", \"description\": \"Team member who defends the goal\"},\r\n    {\"name\": \"referee\", \"parent_type\": \"person\", \"description\": \"Official who enforces rules\"},\r\n    {\"name\": \"field\", \"parent_type\": null, \"description\": \"Playing area\"}\r\n  ]\r\n}\r\n\r\n---\r\n\r\nNOW PROCESS THIS DOMAIN:\r\n\r\n{{domain_description}}\r\n\r\nReturn ONLY valid JSON matching the schema. No markdown, no explanations.\r\n    \"#\r\n}",
    "generate_pddl_azure.baml": "\r\n// Function to generate the PDDL domain file\r\nfunction GeneratePDDLDomainAzure(\r\n  domain_description: string,    // \"A world of blocks with a robot arm...\"\r\n  object_nl: string,   \r\n  attributes_nl: string,\r\n  actions_nl: string\r\n) -> PDDLDomainResult {\r\n  client \"CustomAzure\"\r\n  prompt #\"\r\nYou are a PDDL domain code generator with perfect syntax knowledge.\r\n\r\nTASK: Generate a complete, valid, and executable PDDL domain file.\r\n\r\nCRITICAL SYNTAX RULES:\r\n1. Perfect parenthesis balance - every ( must have matching )\r\n2. Proper spacing: (define (domain name)) NOT (define(domain name))\r\n3. Types section: use \" - \" (space-dash-space) for inheritance\r\n4. Predicate signatures: EXACTLY ONE type per parameter, NO union types\r\n5. Action parameters: MUST have \" - \" before type\r\n6. Effects: use (not (pred)) for deletion, NOT (delete (pred))\r\n\r\nSTRUCTURE REQUIREMENTS:\r\n(define (domain DOMAIN-NAME)\r\n  (:requirements :strips :typing :negative-preconditions :equality)\r\n  \r\n  (:types\r\n    type1 type2 - parent-type\r\n    type3 - object\r\n  )\r\n  \r\n  (:predicates\r\n    (pred-name ?param - type)\r\n    (binary-pred ?p1 - type1 ?p2 - type2)\r\n  )\r\n  \r\n  (:functions\r\n    (func-name ?param - type) - number\r\n  )  ;; ONLY if numeric fluents exist\r\n  \r\n  (:action action-name\r\n    :parameters (?p1 - type1 ?p2 - type2)\r\n    :precondition (and\r\n      (pred1 ?p1)\r\n      (pred2 ?p1 ?p2)\r\n      (> (func ?p1) 0)  ;; for numeric\r\n    )\r\n    :effect (and\r\n      (pred3 ?p2)\r\n      (not (pred1 ?p1))\r\n      (increase (func ?p1) 5)  ;; for numeric\r\n    )\r\n  )\r\n)\r\n\r\nPREDICATE CONVERSION RULES:\r\nInput attribute format: \"Predicate: (robot-at ?r - robot ?l - location)\"\r\nOutput PDDL: (robot-at ?r - robot ?l - location)\r\n\r\nEFFECT CONVERSION:\r\n- \"add (?r ?loc)\" → (robot-at ?r ?loc)\r\n- \"delete (?r ?from)\" → (not (robot-at ?r ?from))\r\n- \"increase by 5\" → (increase (attribute-name ?param) 5)\r\n- \"decrease by 3\" → (decrease (attribute-name ?param) 3)\r\n\r\nCOMMON ERRORS TO AVOID:\r\n❌ (on ?b - (block | table))  →  ✓ Use separate predicates\r\n❌ (on-table ?b - block)      →  ✓ Ensure consistent with attributes\r\n   (on ?b1 ?b2 - block)       \r\n❌ :parameters (?r robot)      →  ✓ :parameters (?r - robot)\r\n❌ (delete (at ?r ?l))         →  ✓ (not (at ?r ?l))\r\n\r\nREQUIREMENTS SELECTION:\r\n- Always: :strips :typing\r\n- If negated preconditions: :negative-preconditions\r\n- If numeric fluents: :fluents :numeric-fluents\r\n- If conditional effects: :conditional-effects\r\n- If equality checks: :equality\r\n\r\nEXAMPLE 1 - Blocksworld:\r\nInput Types: block, robot-arm\r\nInput Predicates: on-table(?b - block), on-block(?b1 - block ?b2 - block), clear(?b - block), arm-empty(?arm - robot-arm), held-by-arm(?b - block ?arm - robot-arm)\r\nInput Actions: pickup(from table), stack, unstack, putdown\r\n\r\nOutput:\r\n(define (domain blocksworld)\r\n  (:requirements :strips :typing :negative-preconditions)\r\n  \r\n  (:types\r\n    block\r\n    robot-arm\r\n  )\r\n  \r\n  (:predicates\r\n    (on-table ?b - block)\r\n    (on-block ?b1 - block ?b2 - block)\r\n    (clear ?b - block)\r\n    (arm-empty ?arm - robot-arm)\r\n    (held-by-arm ?b - block ?arm - robot-arm)\r\n  )\r\n  \r\n  (:action pickup-from-table\r\n    :parameters (?arm - robot-arm ?b - block)\r\n    :precondition (and\r\n      (on-table ?b)\r\n      (clear ?b)\r\n      (arm-empty ?arm)\r\n    )\r\n    :effect (and\r\n      (not (on-table ?b))\r\n      (not (arm-empty ?arm))\r\n      (held-by-arm ?b ?arm)\r\n    )\r\n  )\r\n  \r\n  (:action putdown-on-table\r\n    :parameters (?arm - robot-arm ?b - block)\r\n    :precondition (held-by-arm ?b ?arm)\r\n    :effect (and\r\n      (on-table ?b)\r\n      (clear ?b)\r\n      (arm-empty ?arm)\r\n      (not (held-by-arm ?b ?arm))\r\n    )\r\n  )\r\n  \r\n  (:action stack\r\n    :parameters (?arm - robot-arm ?b1 - block ?b2 - block)\r\n    :precondition (and\r\n      (held-by-arm ?b1 ?arm)\r\n      (clear ?b2)\r\n    )\r\n    :effect (and\r\n      (on-block ?b1 ?b2)\r\n      (clear ?b1)\r\n      (arm-empty ?arm)\r\n      (not (held-by-arm ?b1 ?arm))\r\n      (not (clear ?b2))\r\n    )\r\n  )\r\n  \r\n  (:action unstack\r\n    :parameters (?arm - robot-arm ?b1 - block ?b2 - block)\r\n    :precondition (and\r\n      (on-block ?b1 ?b2)\r\n      (clear ?b1)\r\n      (arm-empty ?arm)\r\n    )\r\n    :effect (and\r\n      (held-by-arm ?b1 ?arm)\r\n      (clear ?b2)\r\n      (not (on-block ?b1 ?b2))\r\n      (not (clear ?b1))\r\n      (not (arm-empty ?arm))\r\n    )\r\n  )\r\n)\r\n\r\nEXAMPLE 2 - Logistics with numeric (fuel):\r\nInput includes: battery-level (numeric 0-100)\r\n\r\nOutput:\r\n(define (domain logistics)\r\n  (:requirements :strips :typing :fluents :numeric-fluents)\r\n  \r\n  (:types\r\n    robot package location\r\n  )\r\n  \r\n  (:predicates\r\n    (robot-at ?r - robot ?l - location)\r\n    (package-at ?p - package ?l - location)\r\n    (carrying ?r - robot ?p - package)\r\n  )\r\n  \r\n  (:functions\r\n    (battery-level ?r - robot) - number\r\n  )\r\n  \r\n  (:action move\r\n    :parameters (?r - robot ?from - location ?to - location)\r\n    :precondition (and\r\n      (robot-at ?r ?from)\r\n      (> (battery-level ?r) 0)\r\n    )\r\n    :effect (and\r\n      (not (robot-at ?r ?from))\r\n      (robot-at ?r ?to)\r\n      (decrease (battery-level ?r) 1)\r\n    )\r\n  )\r\n  \r\n  (:action pickup\r\n    :parameters (?r - robot ?p - package ?loc - location)\r\n    :precondition (and\r\n      (robot-at ?r ?loc)\r\n      (package-at ?p ?loc)\r\n    )\r\n    :effect (and\r\n      (carrying ?r ?p)\r\n      (not (package-at ?p ?loc))\r\n    )\r\n  )\r\n)\r\n\r\n---\r\n\r\nNOW GENERATE PDDL FROM:\r\n\r\nDomain Description:\r\n{{domain_description}}\r\n\r\nTypes (NL):\r\n{{object_nl}}\r\n\r\nPredicates (NL):\r\n{{attributes_nl}}\r\n\r\nActions (NL):\r\n{{actions_nl}}\r\n\r\nCRITICAL: Return ONLY valid JSON:\r\n{\r\n  \"domain_name\": \"lowercase-name\",\r\n  \"pddl_code\": \"complete PDDL code as single string with \\\\n for newlines\",\r\n  \"explanation\": \"brief explanation of key design decisions\"\r\n}\r\n\r\nVerify parenthesis balance before returning. Ensure types match across predicates and actions.\r\n\"#\r\n}",
    "generate_pddl_deep.baml": "\r\n// Function to generate the PDDL domain file\r\nfunction GeneratePDDLDomainDeep(\r\n  domain_description: string,    // \"A world of blocks with a robot arm...\"\r\n  object_nl: string,   \r\n  attributes_nl: string,\r\n  actions_nl: string\r\n) -> PDDLDomainResult {\r\n  client \"CustomDeepSeekCoder\"\r\n  prompt #\"\r\nYou are a PDDL domain code generator with perfect syntax knowledge.\r\n\r\nTASK: Generate a complete, valid, and executable PDDL domain file.\r\n\r\nCRITICAL SYNTAX RULES:\r\n1. Perfect parenthesis balance - every ( must have matching )\r\n2. Proper spacing: (define (domain name)) NOT (define(domain name))\r\n3. Types section: use \" - \" (space-dash-space) for inheritance\r\n4. Predicate signatures: EXACTLY ONE type per parameter, NO union types\r\n5. Action parameters: MUST have \" - \" before type\r\n6. Effects: use (not (pred)) for deletion, NOT (delete (pred))\r\n\r\nSTRUCTURE REQUIREMENTS:\r\n(define (domain DOMAIN-NAME)\r\n  (:requirements :strips :typing :negative-preconditions :equality)\r\n  \r\n  (:types\r\n    type1 type2 - parent-type\r\n    type3 - object\r\n  )\r\n  \r\n  (:predicates\r\n    (pred-name ?param - type)\r\n    (binary-pred ?p1 - type1 ?p2 - type2)\r\n  )\r\n  \r\n  (:functions\r\n    (func-name ?param - type) - number\r\n  )  ;; ONLY if numeric fluents exist\r\n  \r\n  (:action action-name\r\n    :parameters (?p1 - type1 ?p2 - type2)\r\n    :precondition (and\r\n      (pred1 ?p1)\r\n      (pred2 ?p1 ?p2)\r\n      (> (func ?p1) 0)  ;; for numeric\r\n    )\r\n    :effect (and\r\n      (pred3 ?p2)\r\n      (not (pred1 ?p1))\r\n      (increase (func ?p1) 5)  ;; for numeric\r\n    )\r\n  )\r\n)\r\n\r\nPREDICATE CONVERSION RULES:\r\nInput attribute format: \"Predicate: (robot-at ?r - robot ?l - location)\"\r\nOutput PDDL: (robot-at ?r - robot ?l - location)\r\n\r\nEFFECT CONVERSION:\r\n- \"add (?r ?loc)\" → (robot-at ?r ?loc)\r\n- \"delete (?r ?from)\" → (not (robot-at ?r ?from))\r\n- \"increase by 5\" → (increase (attribute-name ?param) 5)\r\n- \"decrease by 3\" → (decrease (attribute-name ?param) 3)\r\n\r\nCOMMON ERRORS TO AVOID:\r\n❌ (on ?b - (block | table))  →  ✓ Use separate predicates\r\n❌ (on-table ?b - block)      →  ✓ Ensure consistent with attributes\r\n   (on ?b1 ?b2 - block)       \r\n❌ :parameters (?r robot)      →  ✓ :parameters (?r - robot)\r\n❌ (delete (at ?r ?l))         →  ✓ (not (at ?r ?l))\r\n\r\nREQUIREMENTS SELECTION:\r\n- Always: :strips :typing\r\n- If negated preconditions: :negative-preconditions\r\n- If numeric fluents: :fluents :numeric-fluents\r\n- If conditional effects: :conditional-effects\r\n- If equality checks: :equality\r\n\r\nEXAMPLE 1 - Blocksworld:\r\nInput Types: block, robot-arm\r\nInput Predicates: on-table(?b - block), on-block(?b1 - block ?b2 - block), clear(?b - block), arm-empty(?arm - robot-arm), held-by-arm(?b - block ?arm - robot-arm)\r\nInput Actions: pickup(from table), stack, unstack, putdown\r\n\r\nOutput:\r\n(define (domain blocksworld)\r\n  (:requirements :strips :typing :negative-preconditions)\r\n  \r\n  (:types\r\n    block\r\n    robot-arm\r\n  )\r\n  \r\n  (:predicates\r\n    (on-table ?b - block)\r\n    (on-block ?b1 - block ?b2 - block)\r\n    (clear ?b - block)\r\n    (arm-empty ?arm - robot-arm)\r\n    (held-by-arm ?b - block ?arm - robot-arm)\r\n  )\r\n  \r\n  (:action pickup-from-table\r\n    :parameters (?arm - robot-arm ?b - block)\r\n    :precondition (and\r\n      (on-table ?b)\r\n      (clear ?b)\r\n      (arm-empty ?arm)\r\n    )\r\n    :effect (and\r\n      (not (on-table ?b))\r\n      (not (arm-empty ?arm))\r\n      (held-by-arm ?b ?arm)\r\n    )\r\n  )\r\n  \r\n  (:action putdown-on-table\r\n    :parameters (?arm - robot-arm ?b - block)\r\n    :precondition (held-by-arm ?b ?arm)\r\n    :effect (and\r\n      (on-table ?b)\r\n      (clear ?b)\r\n      (arm-empty ?arm)\r\n      (not (held-by-arm ?b ?arm))\r\n    )\r\n  )\r\n  \r\n  (:action stack\r\n    :parameters (?arm - robot-arm ?b1 - block ?b2 - block)\r\n    :precondition (and\r\n      (held-by-arm ?b1 ?arm)\r\n      (clear ?b2)\r\n    )\r\n    :effect (and\r\n      (on-block ?b1 ?b2)\r\n      (clear ?b1)\r\n      (arm-empty ?arm)\r\n      (not (held-by-arm ?b1 ?arm))\r\n      (not (clear ?b2))\r\n    )\r\n  )\r\n  \r\n  (:action unstack\r\n    :parameters (?arm - robot-arm ?b1 - block ?b2 - block)\r\n    :precondition (and\r\n      (on-block ?b1 ?b2)\r\n      (clear ?b1)\r\n      (arm-empty ?arm)\r\n    )\r\n    :effect (and\r\n      (held-by-arm ?b1 ?arm)\r\n      (clear ?b2)\r\n      (not (on-block ?b1 ?b2))\r\n      (not (clear ?b1))\r\n      (not (arm-empty ?arm))\r\n    )\r\n  )\r\n)\r\n\r\nEXAMPLE 2 - Logistics with numeric (fuel):\r\nInput includes: battery-level (numeric 0-100)\r\n\r\nOutput:\r\n(define (domain logistics)\r\n  (:requirements :strips :typing :fluents :numeric-fluents)\r\n  \r\n  (:types\r\n    robot package location\r\n  )\r\n  \r\n  (:predicates\r\n    (robot-at ?r - robot ?l - location)\r\n    (package-at ?p - package ?l - location)\r\n    (carrying ?r - robot ?p - package)\r\n  )\r\n  \r\n  (:functions\r\n    (battery-level ?r - robot) - number\r\n  )\r\n  \r\n  (:action move\r\n    :parameters (?r - robot ?from - location ?to - location)\r\n    :precondition (and\r\n      (robot-at ?r ?from)\r\n      (> (battery-level ?r) 0)\r\n    )\r\n    :effect (and\r\n      (not (robot-at ?r ?from))\r\n      (robot-at ?r ?to)\r\n      (decrease (battery-level ?r) 1)\r\n    )\r\n  )\r\n  \r\n  (:action pickup\r\n    :parameters (?r - robot ?p - package ?loc - location)\r\n    :precondition (and\r\n      (robot-at ?r ?loc)\r\n      (package-at ?p ?loc)\r\n    )\r\n    :effect (and\r\n      (carrying ?r ?p)\r\n      (not (package-at ?p ?loc))\r\n    )\r\n  )\r\n)\r\n\r\n---\r\n\r\nNOW GENERATE PDDL FROM:\r\n\r\nDomain Description:\r\n{{domain_description}}\r\n\r\nTypes (NL):\r\n{{object_nl}}\r\n\r\nPredicates (NL):\r\n{{attributes_nl}}\r\n\r\nActions (NL):\r\n{{actions_nl}}\r\n\r\nCRITICAL: Return ONLY valid JSON:\r\n{\r\n  \"domain_name\": \"lowercase-name\",\r\n  \"pddl_code\": \"complete PDDL code as single string with \\\\n for newlines\",\r\n  \"explanation\": \"brief explanation of key design decisions\"\r\n}\r\n\r\nVerify parenthesis balance before returning. Ensure types match across predicates and actions.\r\n\"#\r\n}",
    "generate_pddl_gemini.baml": "// Define the class for the PDDL domain generation result\r\nclass PDDLDomainResult {\r\n  domain_name string @description(\"The inferred name of the PDDL domain (e.g., 'blocksworld', 'logistics')\")\r\n  pddl_code string @description(\"The complete, syntactically correct PDDL domain code, starting with '(define (domain ...)' and ending with the final ')')\")\r\n  explanation string? @description(\"Brief explanation of the generated domain or any assumptions made (e.g., requirements inferred)\")\r\n}\r\n\r\n// Function to generate the PDDL domain file\r\nfunction GeneratePDDLDomainGemini(\r\n  domain_description: string,    // \"A world of blocks with a robot arm...\"\r\n  object_nl: string,   \r\n  attributes_nl: string,\r\n  actions_nl: string           // \"stack(?a, ?b): Stacks block ?a on block ?b. pickup(?a): Picks up block ?a from the table...\"\r\n) -> PDDLDomainResult {\r\n  client \"CustomGemini\"\r\n  prompt #\"\r\nYou are a PDDL domain code generator with perfect syntax knowledge.\r\n\r\nTASK: Generate a complete, valid, and executable PDDL domain file.\r\n\r\nCRITICAL SYNTAX RULES:\r\n1. Perfect parenthesis balance - every ( must have matching )\r\n2. Proper spacing: (define (domain name)) NOT (define(domain name))\r\n3. Types section: use \" - \" (space-dash-space) for inheritance\r\n4. Predicate signatures: EXACTLY ONE type per parameter, NO union types\r\n5. Action parameters: MUST have \" - \" before type\r\n6. Effects: use (not (pred)) for deletion, NOT (delete (pred))\r\n\r\nSTRUCTURE REQUIREMENTS:\r\n(define (domain DOMAIN-NAME)\r\n  (:requirements :strips :typing :negative-preconditions :equality)\r\n  \r\n  (:types\r\n    type1 type2 - parent-type\r\n    type3 - object\r\n  )\r\n  \r\n  (:predicates\r\n    (pred-name ?param - type)\r\n    (binary-pred ?p1 - type1 ?p2 - type2)\r\n  )\r\n  \r\n  (:functions\r\n    (func-name ?param - type) - number\r\n  )  ;; ONLY if numeric fluents exist\r\n  \r\n  (:action action-name\r\n    :parameters (?p1 - type1 ?p2 - type2)\r\n    :precondition (and\r\n      (pred1 ?p1)\r\n      (pred2 ?p1 ?p2)\r\n      (> (func ?p1) 0)  ;; for numeric\r\n    )\r\n    :effect (and\r\n      (pred3 ?p2)\r\n      (not (pred1 ?p1))\r\n      (increase (func ?p1) 5)  ;; for numeric\r\n    )\r\n  )\r\n)\r\n\r\nPREDICATE CONVERSION RULES:\r\nInput attribute format: \"Predicate: (robot-at ?r - robot ?l - location)\"\r\nOutput PDDL: (robot-at ?r - robot ?l - location)\r\n\r\nEFFECT CONVERSION:\r\n- \"add (?r ?loc)\" → (robot-at ?r ?loc)\r\n- \"delete (?r ?from)\" → (not (robot-at ?r ?from))\r\n- \"increase by 5\" → (increase (attribute-name ?param) 5)\r\n- \"decrease by 3\" → (decrease (attribute-name ?param) 3)\r\n\r\nCOMMON ERRORS TO AVOID:\r\n❌ (on ?b - (block | table))  →  ✓ Use separate predicates\r\n❌ (on-table ?b - block)      →  ✓ Ensure consistent with attributes\r\n   (on ?b1 ?b2 - block)       \r\n❌ :parameters (?r robot)      →  ✓ :parameters (?r - robot)\r\n❌ (delete (at ?r ?l))         →  ✓ (not (at ?r ?l))\r\n\r\nREQUIREMENTS SELECTION:\r\n- Always: :strips :typing\r\n- If negated preconditions: :negative-preconditions\r\n- If numeric fluents: :fluents :numeric-fluents\r\n- If conditional effects: :conditional-effects\r\n- If equality checks: :equality\r\n\r\nEXAMPLE 1 - Blocksworld:\r\nInput Types: block, robot-arm\r\nInput Predicates: on-table(?b - block), on-block(?b1 - block ?b2 - block), clear(?b - block), arm-empty(?arm - robot-arm), held-by-arm(?b - block ?arm - robot-arm)\r\nInput Actions: pickup(from table), stack, unstack, putdown\r\n\r\nOutput:\r\n(define (domain blocksworld)\r\n  (:requirements :strips :typing :negative-preconditions)\r\n  \r\n  (:types\r\n    block\r\n    robot-arm\r\n  )\r\n  \r\n  (:predicates\r\n    (on-table ?b - block)\r\n    (on-block ?b1 - block ?b2 - block)\r\n    (clear ?b - block)\r\n    (arm-empty ?arm - robot-arm)\r\n    (held-by-arm ?b - block ?arm - robot-arm)\r\n  )\r\n  \r\n  (:action pickup-from-table\r\n    :parameters (?arm - robot-arm ?b - block)\r\n    :precondition (and\r\n      (on-table ?b)\r\n      (clear ?b)\r\n      (arm-empty ?arm)\r\n    )\r\n    :effect (and\r\n      (not (on-table ?b))\r\n      (not (arm-empty ?arm))\r\n      (held-by-arm ?b ?arm)\r\n    )\r\n  )\r\n  \r\n  (:action putdown-on-table\r\n    :parameters (?arm - robot-arm ?b - block)\r\n    :precondition (held-by-arm ?b ?arm)\r\n    :effect (and\r\n      (on-table ?b)\r\n      (clear ?b)\r\n      (arm-empty ?arm)\r\n      (not (held-by-arm ?b ?arm))\r\n    )\r\n  )\r\n  \r\n  (:action stack\r\n    :parameters (?arm - robot-arm ?b1 - block ?b2 - block)\r\n    :precondition (and\r\n      (held-by-arm ?b1 ?arm)\r\n      (clear ?b2)\r\n    )\r\n    :effect (and\r\n      (on-block ?b1 ?b2)\r\n      (clear ?b1)\r\n      (arm-empty ?arm)\r\n      (not (held-by-arm ?b1 ?arm))\r\n      (not (clear ?b2))\r\n    )\r\n  )\r\n  \r\n  (:action unstack\r\n    :parameters (?arm - robot-arm ?b1 - block ?b2 - block)\r\n    :precondition (and\r\n      (on-block ?b1 ?b2)\r\n      (clear ?b1)\r\n      (arm-empty ?arm)\r\n    )\r\n    :effect (and\r\n      (held-by-arm ?b1 ?arm)\r\n      (clear ?b2)\r\n      (not (on-block ?b1 ?b2))\r\n      (not (clear ?b1))\r\n      (not (arm-empty ?arm))\r\n    )\r\n  )\r\n)\r\n\r\nEXAMPLE 2 - Logistics with numeric (fuel):\r\nInput includes: battery-level (numeric 0-100)\r\n\r\nOutput:\r\n(define (domain logistics)\r\n  (:requirements :strips :typing :fluents :numeric-fluents)\r\n  \r\n  (:types\r\n    robot package location\r\n  )\r\n  \r\n  (:predicates\r\n    (robot-at ?r - robot ?l - location)\r\n    (package-at ?p - package ?l - location)\r\n    (carrying ?r - robot ?p - package)\r\n  )\r\n  \r\n  (:functions\r\n    (battery-level ?r - robot) - number\r\n  )\r\n  \r\n  (:action move\r\n    :parameters (?r - robot ?from - location ?to - location)\r\n    :precondition (and\r\n      (robot-at ?r ?from)\r\n      (> (battery-level ?r) 0)\r\n    )\r\n    :effect (and\r\n      (not (robot-at ?r ?from))\r\n      (robot-at ?r ?to)\r\n      (decrease (battery-level ?r) 1)\r\n    )\r\n  )\r\n  \r\n  (:action pickup\r\n    :parameters (?r - robot ?p - package ?loc - location)\r\n    :precondition (and\r\n      (robot-at ?r ?loc)\r\n      (package-at ?p ?loc)\r\n    )\r\n    :effect (and\r\n      (carrying ?r ?p)\r\n      (not (package-at ?p ?loc))\r\n    )\r\n  )\r\n)\r\n\r\n---\r\n\r\nNOW GENERATE PDDL FROM:\r\n\r\nDomain Description:\r\n{{domain_description}}\r\n\r\nTypes (NL):\r\n{{object_nl}}\r\n\r\nPredicates (NL):\r\n{{attributes_nl}}\r\n\r\nActions (NL):\r\n{{actions_nl}}\r\n\r\nCRITICAL: Return ONLY valid JSON:\r\n{\r\n  \"domain_name\": \"lowercase-name\",\r\n  \"pddl_code\": \"complete PDDL code as single string with \\\\n for newlines\",\r\n  \"explanation\": \"brief explanation of key design decisions\"\r\n}\r\n\r\nVerify parenthesis balance before returning. Ensure types match across predicates and actions.\r\n\"#\r\n}",
    "generate_problem_azure.baml": "\r\n// Function to generate the PDDL problem file\r\nfunction GeneratePDDLProblemAzure(\r\n  problem_description: string, // \"Un problema per impilare tre blocchi...\"\r\n  domain_pddl_code: string,         // \"blocksworld\" (deve corrispondere al dominio)\r\n  objects_baml: string,        // \"a, b, c - block. r1 - robotarm\"\r\n  init_state_baml: string,     // \"(on-table a) (clear a) (on-table b) (clear b) (arm-empty)...\"\r\n  goal_state_baml: string      // \"(on a b) (on b c)\"\r\n) -> PDDLProblemResult {\r\n  client \"CustomAzure\"\r\n  prompt #\"// Define the class for the PDDL problem generation result\r\n\r\n\r\n// Function to generate the PDDL problem file\r\nfunction GeneratePDDLProblem(\r\n  problem_description: string, // \"A task to stack b1 on b2, which is on the table.\"\r\n  objects_nl: string,          // \"b1, b2, b3 are blocks. r1 is a robotarm.\"\r\n  init_state_nl: string,     // \"b1 is on b2. b2 is on the table. b3 is on the table. r1 is empty. b1 and b3 are clear.\"\r\n  goal_state_nl: string,       // \"b1 is on b2 and b2 is on b3.\"\r\n  domain_pddl_code: string     // The full \"(define (domain blocksworld) ...)\" string generated by GeneratePDDLDomainGemini\r\n) -> PDDLProblemResult {\r\n  client \"CustomGemini\"\r\n  prompt #\"\r\nYou are an expert PDDL (Planning Domain Definition Language) problem engineer.\r\n\r\nTASK:\r\nGiven a natural language description of a problem (objects, init, goal) and the\r\n**complete PDDL domain code** it belongs to, generate a\r\n**complete and syntactically valid PDDL problem file**.\r\n\r\n---\r\n\r\n### CONTEXT: DOMAIN PDDL\r\n\r\nYou must use the following PDDL Domain Code to validate types and predicates.\r\nDO NOT generate this domain; use it as context.\r\n\r\n{{ domain_pddl_code }}\r\n\r\n---\r\n\r\n### EXAMPLE\r\n\r\n**Example 1: Blocksworld Problem**\r\n\r\nInput Context:\r\n(Domain PDDL is the one provided above, starting with '(define (domain blocksworld) ...')\r\nProblem Description: \"A simple task to stack three blocks in order.\"\r\nObjects NL: \"We have three blocks: b1, b2, and b3. We also have one robot arm, arm1.\"\r\nInit State NL: \"All three blocks (b1, b2, b3) are on the table. All blocks are clear. The robot arm is empty.\"\r\nGoal State NL: \"The goal is to have b1 on b2, and b2 on b3.\"\r\n\r\nExpected Output:\r\n{\r\n  \"problem_name\": \"stack-three-blocks\",\r\n  \"domain_name\": \"blocksworld\",\r\n  \"pddl_code\": \"(define (problem stack-three-blocks)\\n  (:domain blocksworld)\\n\\n  (:objects\\n    b1 b2 b3 - block\\n    arm1 - robotarm\\n  )\\n\\n  (:init\\n    (on-table b1)\\n    (on-table b2)\\n    (on-table b3)\\n    (clear b1)\\n    (clear b2)\\n    (clear b3)\\n    (arm-empty)\\n  )\\n\\n  (:goal\\n    (and\\n      (on b1 b2)\\n      (on b2 b3)\\n    )\\n  )\\n)\",\r\n  \"explanation\": \"Generated a problem for the 'blocksworld' domain with three blocks, starting from the table and aiming for a 3-stack.\"\r\n}\r\n\r\n---\r\n\r\n### DETAILED INSTRUCTIONS\r\n\r\n1.  **Extract Domain Name (CRITICAL)**: Look at the `domain_pddl_code` input. Find the line `(define (domain ...))` and extract the exact `domain_name` (e.g., 'blocksworld').\r\n2.  **Problem Name**: Infer a suitable, single-word problem name from the `problem_description` (e.g., 'task1', 'problem-stacking').\r\n3.  **Domain Reference**: The problem definition *must* start with `(define (problem <problem_name>)` and *must* include `(:domain <domain_name>)`, where `<domain_name>` is the name you extracted in step 1.\r\n4.  **Objects**:\r\n    * Parse the `objects_nl` string to create the `(:objects ...)` section.\r\n    * You **must** assign a type to every object (e.g., `b1 b2 - block`).\r\n    * The types you use (e.g., `block`, `robotarm`) **must** be types defined in the `(:types ...)` section of the provided `domain_pddl_code`.\r\n5.  **Init State**:\r\n    * Translate the `init_state_nl` string into the `(:init ...)` section.\r\n    * Each statement (e.g., `(on-table b1)`, `(arm-empty)`) **must** use a predicate that is defined in the `(:predicates ...)` section of the `domain_pddl_code`.\r\n    * Pay close attention to arity (e.g., `(on-table b1)` vs `(on b1 b2)`).\r\n6.  **Goal State**:\r\n    * Translate the `goal_state_nl` string into the `(:goal (and ...))` section.\r\n    * These predicates must also match the predicates defined in the `domain_pddl_code`.\r\n7.  **Validity**: The generated PDDL code must be complete and syntactically correct, with balanced parentheses.\r\n8.  **Output**: The output must be **only** the JSON object matching `PDDLProblemResult`. NO additional text or markdown.\r\n\r\n---\r\n\r\n### INPUT\r\n\r\nProblem Description:\r\n---\r\n{{ problem_description }}\r\n---\r\n\r\nObjects NL:\r\n{{ objects_baml }}\r\n\r\nInit State NL:\r\n{{ init_state_baml }}\r\n\r\nGoal State NL:\r\n{{ goal_state_baml }}\r\n\r\n---\r\n\r\n### OUTPUT FORMAT (required)\r\n{\r\n  \"problem_name\": \"nome-del-problema\",\r\n  \"domain_name\": \"nome-del-dominio-estratto\",\r\n  \"pddl_code\": \"(define (problem nome-del-problema)\\n  (:domain nome-del-dominio-estratto)\\n\\n  (:objects\\n    ...\\n  )\\n\\n  (:init\\n    ...\\n  )\\n\\n  (:goal\\n    (and ...)\\n  )\\n)\",\r\n  \"explanation\": \"Una breve spiegazione di ciò che è stato generato o di eventuali assunzioni fatte.\"\r\n}\r\n\r\n\"#\r\n}",
    "generate_problem_deep.baml": "\r\n// Function to generate the PDDL problem file\r\nfunction GeneratePDDLProblemDeep(\r\n  problem_description: string, // \"Un problema per impilare tre blocchi...\"\r\n  domain_pddl_code: string,         // \"blocksworld\" (deve corrispondere al dominio)\r\n  objects_baml: string,        // \"a, b, c - block. r1 - robotarm\"\r\n  init_state_baml: string,     // \"(on-table a) (clear a) (on-table b) (clear b) (arm-empty)...\"\r\n  goal_state_baml: string      // \"(on a b) (on b c)\"\r\n) -> PDDLProblemResult {\r\n  client \"CustomDeepSeekCoder\"\r\n  prompt #\"// Define the class for the PDDL problem generation result\r\n\r\n\r\n// Function to generate the PDDL problem file\r\nfunction GeneratePDDLProblem(\r\n  problem_description: string, // \"A task to stack b1 on b2, which is on the table.\"\r\n  objects_nl: string,          // \"b1, b2, b3 are blocks. r1 is a robotarm.\"\r\n  init_state_nl: string,     // \"b1 is on b2. b2 is on the table. b3 is on the table. r1 is empty. b1 and b3 are clear.\"\r\n  goal_state_nl: string,       // \"b1 is on b2 and b2 is on b3.\"\r\n  domain_pddl_code: string     // The full \"(define (domain blocksworld) ...)\" string generated by GeneratePDDLDomainGemini\r\n) -> PDDLProblemResult {\r\n  client \"CustomGemini\"\r\n  prompt #\"\r\nYou are an expert PDDL (Planning Domain Definition Language) problem engineer.\r\n\r\nTASK:\r\nGiven a natural language description of a problem (objects, init, goal) and the\r\n**complete PDDL domain code** it belongs to, generate a\r\n**complete and syntactically valid PDDL problem file**.\r\n\r\n---\r\n\r\n### CONTEXT: DOMAIN PDDL\r\n\r\nYou must use the following PDDL Domain Code to validate types and predicates.\r\nDO NOT generate this domain; use it as context.\r\n\r\n{{ domain_pddl_code }}\r\n\r\n---\r\n\r\n### EXAMPLE\r\n\r\n**Example 1: Blocksworld Problem**\r\n\r\nInput Context:\r\n(Domain PDDL is the one provided above, starting with '(define (domain blocksworld) ...')\r\nProblem Description: \"A simple task to stack three blocks in order.\"\r\nObjects NL: \"We have three blocks: b1, b2, and b3. We also have one robot arm, arm1.\"\r\nInit State NL: \"All three blocks (b1, b2, b3) are on the table. All blocks are clear. The robot arm is empty.\"\r\nGoal State NL: \"The goal is to have b1 on b2, and b2 on b3.\"\r\n\r\nExpected Output:\r\n{\r\n  \"problem_name\": \"stack-three-blocks\",\r\n  \"domain_name\": \"blocksworld\",\r\n  \"pddl_code\": \"(define (problem stack-three-blocks)\\n  (:domain blocksworld)\\n\\n  (:objects\\n    b1 b2 b3 - block\\n    arm1 - robotarm\\n  )\\n\\n  (:init\\n    (on-table b1)\\n    (on-table b2)\\n    (on-table b3)\\n    (clear b1)\\n    (clear b2)\\n    (clear b3)\\n    (arm-empty)\\n  )\\n\\n  (:goal\\n    (and\\n      (on b1 b2)\\n      (on b2 b3)\\n    )\\n  )\\n)\",\r\n  \"explanation\": \"Generated a problem for the 'blocksworld' domain with three blocks, starting from the table and aiming for a 3-stack.\"\r\n}\r\n\r\n---\r\n\r\n### DETAILED INSTRUCTIONS\r\n\r\n1.  **Extract Domain Name (CRITICAL)**: Look at the `domain_pddl_code` input. Find the line `(define (domain ...))` and extract the exact `domain_name` (e.g., 'blocksworld').\r\n2.  **Problem Name**: Infer a suitable, single-word problem name from the `problem_description` (e.g., 'task1', 'problem-stacking').\r\n3.  **Domain Reference**: The problem definition *must* start with `(define (problem <problem_name>)` and *must* include `(:domain <domain_name>)`, where `<domain_name>` is the name you extracted in step 1.\r\n4.  **Objects**:\r\n    * Parse the `objects_nl` string to create the `(:objects ...)` section.\r\n    * You **must** assign a type to every object (e.g., `b1 b2 - block`).\r\n    * The types you use (e.g., `block`, `robotarm`) **must** be types defined in the `(:types ...)` section of the provided `domain_pddl_code`.\r\n5.  **Init State**:\r\n    * Translate the `init_state_nl` string into the `(:init ...)` section.\r\n    * Each statement (e.g., `(on-table b1)`, `(arm-empty)`) **must** use a predicate that is defined in the `(:predicates ...)` section of the `domain_pddl_code`.\r\n    * Pay close attention to arity (e.g., `(on-table b1)` vs `(on b1 b2)`).\r\n6.  **Goal State**:\r\n    * Translate the `goal_state_nl` string into the `(:goal (and ...))` section.\r\n    * These predicates must also match the predicates defined in the `domain_pddl_code`.\r\n7.  **Validity**: The generated PDDL code must be complete and syntactically correct, with balanced parentheses.\r\n8.  **Output**: The output must be **only** the JSON object matching `PDDLProblemResult`. NO additional text or markdown.\r\n\r\n---\r\n\r\n### INPUT\r\n\r\nProblem Description:\r\n---\r\n{{ problem_description }}\r\n---\r\n\r\nObjects NL:\r\n{{ objects_baml }}\r\n\r\nInit State NL:\r\n{{ init_state_baml }}\r\n\r\nGoal State NL:\r\n{{ goal_state_baml }}\r\n\r\n---\r\n\r\n### OUTPUT FORMAT (required)\r\n{\r\n  \"problem_name\": \"nome-del-problema\",\r\n  \"domain_name\": \"nome-del-dominio-estratto\",\r\n  \"pddl_code\": \"(define (problem nome-del-problema)\\n  (:domain nome-del-dominio-estratto)\\n\\n  (:objects\\n    ...\\n  )\\n\\n  (:init\\n    ...\\n  )\\n\\n  (:goal\\n    (and ...)\\n  )\\n)\",\r\n  \"explanation\": \"Una breve spiegazione di ciò che è stato generato o di eventuali assunzioni fatte.\"\r\n}\r\n\r\n\"#\r\n}",
    "generate_problem_gemini.baml": "class PDDLProblemResult {\r\n  problem_name string @description(\"The inferred name of the PDDL problem (e.g., 'problem-1', 'task-stack-blocks')\")\r\n  domain_name string @description(\"The name of the domain this problem belongs to, extracted from the domain_pddl_code (e.g., 'blocksworld')\")\r\n  pddl_code string @description(\"The complete, syntactically correct PDDL problem code, starting with '(define (problem ...)' and ending with the final ')')\")\r\n  explanation string? @description(\"Brief explanation of the generated problem or any assumptions made (e.g., how the NL init state was translated)\")\r\n}\r\n\r\n// Function to generate the PDDL problem file\r\nfunction GeneratePDDLProblemGemini(\r\n  problem_description: string, // \"Un problema per impilare tre blocchi...\"\r\n  domain_pddl_code: string,         // \"blocksworld\" (deve corrispondere al dominio)\r\n  objects_baml: string,        // \"a, b, c - block. r1 - robotarm\"\r\n  init_state_baml: string,     // \"(on-table a) (clear a) (on-table b) (clear b) (arm-empty)...\"\r\n  goal_state_baml: string      // \"(on a b) (on b c)\"\r\n) -> PDDLProblemResult {\r\n  client \"CustomGemini\"\r\n  prompt #\"// Define the class for the PDDL problem generation result\r\n\r\n\r\n// Function to generate the PDDL problem file\r\nfunction GeneratePDDLProblem(\r\n  problem_description: string, // \"A task to stack b1 on b2, which is on the table.\"\r\n  objects_nl: string,          // \"b1, b2, b3 are blocks. r1 is a robotarm.\"\r\n  init_state_nl: string,     // \"b1 is on b2. b2 is on the table. b3 is on the table. r1 is empty. b1 and b3 are clear.\"\r\n  goal_state_nl: string,       // \"b1 is on b2 and b2 is on b3.\"\r\n  domain_pddl_code: string     // The full \"(define (domain blocksworld) ...)\" string generated by GeneratePDDLDomainGemini\r\n) -> PDDLProblemResult {\r\n  client \"CustomGemini\"\r\n  prompt #\"\r\nYou are an expert PDDL (Planning Domain Definition Language) problem engineer.\r\n\r\nTASK:\r\nGiven a natural language description of a problem (objects, init, goal) and the\r\n**complete PDDL domain code** it belongs to, generate a\r\n**complete and syntactically valid PDDL problem file**.\r\n\r\n---\r\n\r\n### CONTEXT: DOMAIN PDDL\r\n\r\nYou must use the following PDDL Domain Code to validate types and predicates.\r\nDO NOT generate this domain; use it as context.\r\n\r\n{{ domain_pddl_code }}\r\n\r\n---\r\n\r\n### EXAMPLE\r\n\r\n**Example 1: Blocksworld Problem**\r\n\r\nInput Context:\r\n(Domain PDDL is the one provided above, starting with '(define (domain blocksworld) ...')\r\nProblem Description: \"A simple task to stack three blocks in order.\"\r\nObjects NL: \"We have three blocks: b1, b2, and b3. We also have one robot arm, arm1.\"\r\nInit State NL: \"All three blocks (b1, b2, b3) are on the table. All blocks are clear. The robot arm is empty.\"\r\nGoal State NL: \"The goal is to have b1 on b2, and b2 on b3.\"\r\n\r\nExpected Output:\r\n{\r\n  \"problem_name\": \"stack-three-blocks\",\r\n  \"domain_name\": \"blocksworld\",\r\n  \"pddl_code\": \"(define (problem stack-three-blocks)\\n  (:domain blocksworld)\\n\\n  (:objects\\n    b1 b2 b3 - block\\n    arm1 - robotarm\\n  )\\n\\n  (:init\\n    (on-table b1)\\n    (on-table b2)\\n    (on-table b3)\\n    (clear b1)\\n    (clear b2)\\n    (clear b3)\\n    (arm-empty)\\n  )\\n\\n  (:goal\\n    (and\\n      (on b1 b2)\\n      (on b2 b3)\\n    )\\n  )\\n)\",\r\n  \"explanation\": \"Generated a problem for the 'blocksworld' domain with three blocks, starting from the table and aiming for a 3-stack.\"\r\n}\r\n\r\n---\r\n\r\n### DETAILED INSTRUCTIONS\r\n\r\n1.  **Extract Domain Name (CRITICAL)**: Look at the `domain_pddl_code` input. Find the line `(define (domain ...))` and extract the exact `domain_name` (e.g., 'blocksworld').\r\n2.  **Problem Name**: Infer a suitable, single-word problem name from the `problem_description` (e.g., 'task1', 'problem-stacking').\r\n3.  **Domain Reference**: The problem definition *must* start with `(define (problem <problem_name>)` and *must* include `(:domain <domain_name>)`, where `<domain_name>` is the name you extracted in step 1.\r\n4.  **Objects**:\r\n    * Parse the `objects_nl` string to create the `(:objects ...)` section.\r\n    * You **must** assign a type to every object (e.g., `b1 b2 - block`).\r\n    * The types you use (e.g., `block`, `robotarm`) **must** be types defined in the `(:types ...)` section of the provided `domain_pddl_code`.\r\n5.  **Init State**:\r\n    * Translate the `init_state_nl` string into the `(:init ...)` section.\r\n    * Each statement (e.g., `(on-table b1)`, `(arm-empty)`) **must** use a predicate that is defined in the `(:predicates ...)` section of the `domain_pddl_code`.\r\n    * Pay close attention to arity (e.g., `(on-table b1)` vs `(on b1 b2)`).\r\n6.  **Goal State**:\r\n    * Translate the `goal_state_nl` string into the `(:goal (and ...))` section.\r\n    * These predicates must also match the predicates defined in the `domain_pddl_code`.\r\n7.  **Validity**: The generated PDDL code must be complete and syntactically correct, with balanced parentheses.\r\n8.  **Output**: The output must be **only** the JSON object matching `PDDLProblemResult`. NO additional text or markdown.\r\n\r\n---\r\n\r\n### INPUT\r\n\r\nProblem Description:\r\n---\r\n{{ problem_description }}\r\n---\r\n\r\nObjects NL:\r\n{{ objects_baml }}\r\n\r\nInit State NL:\r\n{{ init_state_baml }}\r\n\r\nGoal State NL:\r\n{{ goal_state_baml }}\r\n\r\n---\r\n\r\n### OUTPUT FORMAT (required)\r\n{\r\n  \"problem_name\": \"nome-del-problema\",\r\n  \"domain_name\": \"nome-del-dominio-estratto\",\r\n  \"pddl_code\": \"(define (problem nome-del-problema)\\n  (:domain nome-del-dominio-estratto)\\n\\n  (:objects\\n    ...\\n  )\\n\\n  (:init\\n    ...\\n  )\\n\\n  (:goal\\n    (and ...)\\n  )\\n)\",\r\n  \"explanation\": \"Una breve spiegazione di ciò che è stato generato o di eventuali assunzioni fatte.\"\r\n}\r\n\r\n\"#\r\n}",
    "generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"python/pydantic\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../\"\n\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n    // The BAML VSCode extension version should also match this version.\n    version \"0.213.0\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode sync\n}\n",
    "refined_azure.baml": "// Funzione BAML di Refactoring\r\nfunction RefineAndAggregateDomainAzure(\r\n    domain_description: string,\r\n    object_types: string,\r\n    attributes: string,\r\n    actions_list: string \r\n) -> RefinedActionsResult {\r\n    client \"CustomAzure\"\r\n    prompt #\"\r\nYou are an expert PDDL domain engineer specializing in semantic inference and action refinement.\r\n\r\nCRITICAL TASK RULES:\r\n1. **PRESERVE ALL ACTIONS**: Output count MUST equal or exceed input count. NEVER remove actions.\r\n2. **INFER IMPLICIT CONSTRAINTS**: Add missing preconditions based on domain semantics\r\n3. **COMPLETE EFFECTS**: Ensure all state changes are explicitly listed\r\n4. **CONSISTENT NAMING**: Use EXACT attribute names from the provided attributes\r\n\r\n---\r\n\r\nINPUTS:\r\n\r\nDomain Description:\r\n{{ domain_description }}\r\n\r\nValid Types (JSON):\r\n{{ object_types }}\r\n\r\nValid Attributes/Predicates (JSON):\r\n{{ attributes }}\r\n\r\nActions to Refine (JSON):\r\n{{ actions_list }}\r\n\r\n---\r\n\r\nREFINEMENT RULES:\r\n\r\nA. PRECONDITION INFERENCE:\r\n   - If domain mentions \"obstacles\", \"blocked\", \"occupied\" → add clearance checks\r\n   - If domain mentions \"capacity\", \"limit\", \"full\" → add resource constraints\r\n   - If action modifies object state → check current state first\r\n   - If action needs empty/available resource → add availability check\r\n   - If locations/positions matter → add location preconditions\r\n\r\nB. EFFECT COMPLETENESS:\r\n   - For movement: delete old location, add new location\r\n   - For pickup: change holder, remove from previous location\r\n   - For resource consumption: decrease/increase numeric fluents\r\n   - For state changes: add new state, delete old state\r\n\r\nC. ADL DETECTION:\r\n   Set requires_adl = \"true\" if:\r\n   - Action affects ALL objects of a type (e.g., \"unload all packages\")\r\n   - Effects depend on conditions (e.g., \"damage if collision\")\r\n   - Quantifiers needed (forall, exists)\r\n   Otherwise: requires_adl = \"false\"\r\n\r\nD. PARAMETER FORMAT:\r\n   - Always include ? prefix: \"?r\", \"?from\", \"?to\"\r\n   - Match types exactly from object_types input\r\n   - Include ALL objects involved in the action\r\n\r\nE. CONDITION/EFFECT FORMAT:\r\n   Preconditions:\r\n   - Predicates: \"(?param1 ?param2) = true\" or \"(?param) = false\"\r\n   - Numeric: \"> 0\", \">= 5\", \"< 100\", \"!= 0\"\r\n   \r\n   Effects:\r\n   - Add predicate: \"add (?p1 ?p2)\"\r\n   - Delete predicate: \"delete (?p1 ?p2)\"\r\n   - Increase: \"increase by 5\"\r\n   - Decrease: \"decrease by 3\"\r\n   - Set: \"set to 100\"\r\n\r\n---\r\n\r\nEXAMPLES:\r\n\r\nExample 1: Simple movement with inferred clearance\r\nInput Action:\r\n{\r\n  \"name\": \"move\",\r\n  \"actor\": \"robot\",\r\n  \"parameters\": [{\"name\": \"?r\", \"type\": \"robot\"}, {\"name\": \"?from\", \"type\": \"location\"}, {\"name\": \"?to\", \"type\": \"location\"}],\r\n  \"preconditions\": [{\"attribute\": \"at\", \"condition\": \"(?r ?from) = true\"}],\r\n  \"effects\": [{\"attribute\": \"at\", \"change\": \"delete (?r ?from)\"}, {\"attribute\": \"at\", \"change\": \"add (?r ?to)\"}],\r\n  \"description\": \"Move robot\"\r\n}\r\n\r\nDomain mentions: \"Some locations are blocked by obstacles\"\r\n\r\nExpected Output:\r\n{\r\n  \"name\": \"move\",\r\n  \"description\": \"Move robot from one location to another if destination is clear\",\r\n  \"actor\": \"robot\",\r\n  \"parameters\": [\r\n    {\"name\": \"?r\", \"type\": \"robot\"},\r\n    {\"name\": \"?from\", \"type\": \"location\"},\r\n    {\"name\": \"?to\", \"type\": \"location\"}\r\n  ],\r\n  \"preconditions\": [\r\n    {\"attribute\": \"at\", \"condition\": \"(?r ?from) = true\"},\r\n    {\"attribute\": \"clear\", \"condition\": \"(?to) = true\"}\r\n  ],\r\n  \"effects\": [\r\n    {\"attribute\": \"at\", \"change\": \"delete (?r ?from)\"},\r\n    {\"attribute\": \"at\", \"change\": \"add (?r ?to)\"}\r\n  ],\r\n  \"requires_adl\": \"false\"\r\n}\r\n\r\n---\r\n\r\nExample 2: Pickup with implicit preconditions\r\nInput Action:\r\n{\r\n  \"name\": \"pickup\",\r\n  \"actor\": \"robot\",\r\n  \"parameters\": [{\"name\": \"?r\", \"type\": \"robot\"}, {\"name\": \"?p\", \"type\": \"package\"}],\r\n  \"preconditions\": [],\r\n  \"effects\": [{\"attribute\": \"holding\", \"change\": \"add (?r ?p)\"}],\r\n  \"description\": \"Pick up package\"\r\n}\r\n\r\nDomain mentions: \"Robot can carry one package at a time. Robot and package must be at same location.\"\r\n\r\nExpected Output:\r\n{\r\n  \"name\": \"pickup\",\r\n  \"description\": \"Robot picks up a package from the same location if hands are empty\",\r\n  \"actor\": \"robot\",\r\n  \"parameters\": [\r\n    {\"name\": \"?r\", \"type\": \"robot\"},\r\n    {\"name\": \"?p\", \"type\": \"package\"},\r\n    {\"name\": \"?loc\", \"type\": \"location\"}\r\n  ],\r\n  \"preconditions\": [\r\n    {\"attribute\": \"at\", \"condition\": \"(?r ?loc) = true\"},\r\n    {\"attribute\": \"at\", \"condition\": \"(?p ?loc) = true\"},\r\n    {\"attribute\": \"hands-empty\", \"condition\": \"(?r) = true\"}\r\n  ],\r\n  \"effects\": [\r\n    {\"attribute\": \"holding\", \"change\": \"add (?r ?p)\"},\r\n    {\"attribute\": \"at\", \"change\": \"delete (?p ?loc)\"},\r\n    {\"attribute\": \"hands-empty\", \"change\": \"delete (?r)\"}\r\n  ],\r\n  \"requires_adl\": \"false\"\r\n}\r\n\r\n---\r\n\r\nExample 3: Action with numeric fluent\r\nInput Action:\r\n{\r\n  \"name\": \"drive\",\r\n  \"actor\": \"truck\",\r\n  \"parameters\": [{\"name\": \"?t\", \"type\": \"truck\"}, {\"name\": \"?from\", \"type\": \"city\"}, {\"name\": \"?to\", \"type\": \"city\"}],\r\n  \"preconditions\": [{\"attribute\": \"truck-at\", \"condition\": \"(?t ?from) = true\"}],\r\n  \"effects\": [{\"attribute\": \"truck-at\", \"change\": \"delete (?t ?from)\"}, {\"attribute\": \"truck-at\", \"change\": \"add (?t ?to)\"}],\r\n  \"description\": \"Drive truck\"\r\n}\r\n\r\nDomain mentions: \"Trucks consume 10 fuel per trip. Fuel ranges 0-100.\"\r\n\r\nExpected Output:\r\n{\r\n  \"name\": \"drive\",\r\n  \"description\": \"Drive truck between cities consuming fuel\",\r\n  \"actor\": \"truck\",\r\n  \"parameters\": [\r\n    {\"name\": \"?t\", \"type\": \"truck\"},\r\n    {\"name\": \"?from\", \"type\": \"city\"},\r\n    {\"name\": \"?to\", \"type\": \"city\"}\r\n  ],\r\n  \"preconditions\": [\r\n    {\"attribute\": \"truck-at\", \"condition\": \"(?t ?from) = true\"},\r\n    {\"attribute\": \"fuel\", \"condition\": \">= 10\"}\r\n  ],\r\n  \"effects\": [\r\n    {\"attribute\": \"truck-at\", \"change\": \"delete (?t ?from)\"},\r\n    {\"attribute\": \"truck-at\", \"change\": \"add (?t ?to)\"},\r\n    {\"attribute\": \"fuel\", \"change\": \"decrease by 10\"}\r\n  ],\r\n  \"requires_adl\": \"false\"\r\n}\r\n\r\n---\r\n\r\nExample 4: ADL action (affects multiple objects)\r\nInput Action:\r\n{\r\n  \"name\": \"unload-all\",\r\n  \"actor\": \"truck\",\r\n  \"parameters\": [{\"name\": \"?t\", \"type\": \"truck\"}, {\"name\": \"?loc\", \"type\": \"location\"}],\r\n  \"preconditions\": [{\"attribute\": \"truck-at\", \"condition\": \"(?t ?loc) = true\"}],\r\n  \"effects\": [{\"attribute\": \"in-truck\", \"change\": \"delete all packages from ?t\"}],\r\n  \"description\": \"Unload all packages\"\r\n}\r\n\r\nExpected Output:\r\n{\r\n  \"name\": \"unload-all\",\r\n  \"description\": \"Unload all packages from truck to current location (requires ADL for forall)\",\r\n  \"actor\": \"truck\",\r\n  \"parameters\": [\r\n    {\"name\": \"?t\", \"type\": \"truck\"},\r\n    {\"name\": \"?loc\", \"type\": \"location\"}\r\n  ],\r\n  \"preconditions\": [\r\n    {\"attribute\": \"truck-at\", \"condition\": \"(?t ?loc) = true\"}\r\n  ],\r\n  \"effects\": [\r\n    {\"attribute\": \"in-truck\", \"change\": \"delete (?p ?t) for all ?p\"},\r\n    {\"attribute\": \"package-at\", \"change\": \"add (?p ?loc) for all ?p in ?t\"}\r\n  ],\r\n  \"requires_adl\": \"true\"\r\n}\r\n\r\n---\r\n\r\nVALIDATION CHECKLIST:\r\n☑ Output has AT LEAST as many actions as input (never fewer)\r\n☑ Every parameter has ? prefix and valid type\r\n☑ Every attribute name exists in the attributes input\r\n☑ Preconditions use correct format: \"(?p1 ?p2) = true/false\" or \"> N\"\r\n☑ Effects use correct format: \"add/delete (?p1 ?p2)\" or \"increase/decrease by N\"\r\n☑ ADL flag is \"true\" or \"false\" (string, not boolean)\r\n\r\n---\r\n\r\nNOW REFINE THE ACTIONS:\r\n\r\nStep 1: Count input actions\r\nStep 2: For EACH action, infer missing preconditions from domain semantics\r\nStep 3: Complete all effects\r\nStep 4: Determine if ADL is needed\r\nStep 5: Verify output count >= input count\r\n\r\nReturn ONLY valid JSON matching the RefinedActionsResult schema:\r\n{\r\n  \"actions\": [\r\n    {\r\n      \"name\": \"action-name\",\r\n      \"description\": \"what it does\",\r\n      \"actor\": \"type-name\",\r\n      \"parameters\": [{\"name\": \"?param\", \"type\": \"type\"}],\r\n      \"preconditions\": [{\"attribute\": \"pred-name\", \"condition\": \"(?p) = true\"}],\r\n      \"effects\": [{\"attribute\": \"pred-name\", \"change\": \"add (?p1 ?p2)\"}],\r\n      \"requires_adl\": \"false\"\r\n    }\r\n  ]\r\n}\r\n\"#\r\n}",
    "refined_deep.baml": "// Funzione BAML di Refactoring\r\nfunction RefineAndAggregateDomainDeep(\r\n    domain_description: string,\r\n    object_types: string,\r\n    attributes: string,\r\n    actions_list: string \r\n) -> RefinedActionsResult {\r\n    client \"CustomDeepSeekCoder\"\r\n    prompt #\"\r\nYou are an expert PDDL domain engineer specializing in semantic inference and action refinement.\r\n\r\nCRITICAL TASK RULES:\r\n1. **PRESERVE ALL ACTIONS**: Output count MUST equal or exceed input count. NEVER remove actions.\r\n2. **INFER IMPLICIT CONSTRAINTS**: Add missing preconditions based on domain semantics\r\n3. **COMPLETE EFFECTS**: Ensure all state changes are explicitly listed\r\n4. **CONSISTENT NAMING**: Use EXACT attribute names from the provided attributes\r\n\r\n---\r\n\r\nINPUTS:\r\n\r\nDomain Description:\r\n{{ domain_description }}\r\n\r\nValid Types (JSON):\r\n{{ object_types }}\r\n\r\nValid Attributes/Predicates (JSON):\r\n{{ attributes }}\r\n\r\nActions to Refine (JSON):\r\n{{ actions_list }}\r\n\r\n---\r\n\r\nREFINEMENT RULES:\r\n\r\nA. PRECONDITION INFERENCE:\r\n   - If domain mentions \"obstacles\", \"blocked\", \"occupied\" → add clearance checks\r\n   - If domain mentions \"capacity\", \"limit\", \"full\" → add resource constraints\r\n   - If action modifies object state → check current state first\r\n   - If action needs empty/available resource → add availability check\r\n   - If locations/positions matter → add location preconditions\r\n\r\nB. EFFECT COMPLETENESS:\r\n   - For movement: delete old location, add new location\r\n   - For pickup: change holder, remove from previous location\r\n   - For resource consumption: decrease/increase numeric fluents\r\n   - For state changes: add new state, delete old state\r\n\r\nC. ADL DETECTION:\r\n   Set requires_adl = \"true\" if:\r\n   - Action affects ALL objects of a type (e.g., \"unload all packages\")\r\n   - Effects depend on conditions (e.g., \"damage if collision\")\r\n   - Quantifiers needed (forall, exists)\r\n   Otherwise: requires_adl = \"false\"\r\n\r\nD. PARAMETER FORMAT:\r\n   - Always include ? prefix: \"?r\", \"?from\", \"?to\"\r\n   - Match types exactly from object_types input\r\n   - Include ALL objects involved in the action\r\n\r\nE. CONDITION/EFFECT FORMAT:\r\n   Preconditions:\r\n   - Predicates: \"(?param1 ?param2) = true\" or \"(?param) = false\"\r\n   - Numeric: \"> 0\", \">= 5\", \"< 100\", \"!= 0\"\r\n   \r\n   Effects:\r\n   - Add predicate: \"add (?p1 ?p2)\"\r\n   - Delete predicate: \"delete (?p1 ?p2)\"\r\n   - Increase: \"increase by 5\"\r\n   - Decrease: \"decrease by 3\"\r\n   - Set: \"set to 100\"\r\n\r\n---\r\n\r\nEXAMPLES:\r\n\r\nExample 1: Simple movement with inferred clearance\r\nInput Action:\r\n{\r\n  \"name\": \"move\",\r\n  \"actor\": \"robot\",\r\n  \"parameters\": [{\"name\": \"?r\", \"type\": \"robot\"}, {\"name\": \"?from\", \"type\": \"location\"}, {\"name\": \"?to\", \"type\": \"location\"}],\r\n  \"preconditions\": [{\"attribute\": \"at\", \"condition\": \"(?r ?from) = true\"}],\r\n  \"effects\": [{\"attribute\": \"at\", \"change\": \"delete (?r ?from)\"}, {\"attribute\": \"at\", \"change\": \"add (?r ?to)\"}],\r\n  \"description\": \"Move robot\"\r\n}\r\n\r\nDomain mentions: \"Some locations are blocked by obstacles\"\r\n\r\nExpected Output:\r\n{\r\n  \"name\": \"move\",\r\n  \"description\": \"Move robot from one location to another if destination is clear\",\r\n  \"actor\": \"robot\",\r\n  \"parameters\": [\r\n    {\"name\": \"?r\", \"type\": \"robot\"},\r\n    {\"name\": \"?from\", \"type\": \"location\"},\r\n    {\"name\": \"?to\", \"type\": \"location\"}\r\n  ],\r\n  \"preconditions\": [\r\n    {\"attribute\": \"at\", \"condition\": \"(?r ?from) = true\"},\r\n    {\"attribute\": \"clear\", \"condition\": \"(?to) = true\"}\r\n  ],\r\n  \"effects\": [\r\n    {\"attribute\": \"at\", \"change\": \"delete (?r ?from)\"},\r\n    {\"attribute\": \"at\", \"change\": \"add (?r ?to)\"}\r\n  ],\r\n  \"requires_adl\": \"false\"\r\n}\r\n\r\n---\r\n\r\nExample 2: Pickup with implicit preconditions\r\nInput Action:\r\n{\r\n  \"name\": \"pickup\",\r\n  \"actor\": \"robot\",\r\n  \"parameters\": [{\"name\": \"?r\", \"type\": \"robot\"}, {\"name\": \"?p\", \"type\": \"package\"}],\r\n  \"preconditions\": [],\r\n  \"effects\": [{\"attribute\": \"holding\", \"change\": \"add (?r ?p)\"}],\r\n  \"description\": \"Pick up package\"\r\n}\r\n\r\nDomain mentions: \"Robot can carry one package at a time. Robot and package must be at same location.\"\r\n\r\nExpected Output:\r\n{\r\n  \"name\": \"pickup\",\r\n  \"description\": \"Robot picks up a package from the same location if hands are empty\",\r\n  \"actor\": \"robot\",\r\n  \"parameters\": [\r\n    {\"name\": \"?r\", \"type\": \"robot\"},\r\n    {\"name\": \"?p\", \"type\": \"package\"},\r\n    {\"name\": \"?loc\", \"type\": \"location\"}\r\n  ],\r\n  \"preconditions\": [\r\n    {\"attribute\": \"at\", \"condition\": \"(?r ?loc) = true\"},\r\n    {\"attribute\": \"at\", \"condition\": \"(?p ?loc) = true\"},\r\n    {\"attribute\": \"hands-empty\", \"condition\": \"(?r) = true\"}\r\n  ],\r\n  \"effects\": [\r\n    {\"attribute\": \"holding\", \"change\": \"add (?r ?p)\"},\r\n    {\"attribute\": \"at\", \"change\": \"delete (?p ?loc)\"},\r\n    {\"attribute\": \"hands-empty\", \"change\": \"delete (?r)\"}\r\n  ],\r\n  \"requires_adl\": \"false\"\r\n}\r\n\r\n---\r\n\r\nExample 3: Action with numeric fluent\r\nInput Action:\r\n{\r\n  \"name\": \"drive\",\r\n  \"actor\": \"truck\",\r\n  \"parameters\": [{\"name\": \"?t\", \"type\": \"truck\"}, {\"name\": \"?from\", \"type\": \"city\"}, {\"name\": \"?to\", \"type\": \"city\"}],\r\n  \"preconditions\": [{\"attribute\": \"truck-at\", \"condition\": \"(?t ?from) = true\"}],\r\n  \"effects\": [{\"attribute\": \"truck-at\", \"change\": \"delete (?t ?from)\"}, {\"attribute\": \"truck-at\", \"change\": \"add (?t ?to)\"}],\r\n  \"description\": \"Drive truck\"\r\n}\r\n\r\nDomain mentions: \"Trucks consume 10 fuel per trip. Fuel ranges 0-100.\"\r\n\r\nExpected Output:\r\n{\r\n  \"name\": \"drive\",\r\n  \"description\": \"Drive truck between cities consuming fuel\",\r\n  \"actor\": \"truck\",\r\n  \"parameters\": [\r\n    {\"name\": \"?t\", \"type\": \"truck\"},\r\n    {\"name\": \"?from\", \"type\": \"city\"},\r\n    {\"name\": \"?to\", \"type\": \"city\"}\r\n  ],\r\n  \"preconditions\": [\r\n    {\"attribute\": \"truck-at\", \"condition\": \"(?t ?from) = true\"},\r\n    {\"attribute\": \"fuel\", \"condition\": \">= 10\"}\r\n  ],\r\n  \"effects\": [\r\n    {\"attribute\": \"truck-at\", \"change\": \"delete (?t ?from)\"},\r\n    {\"attribute\": \"truck-at\", \"change\": \"add (?t ?to)\"},\r\n    {\"attribute\": \"fuel\", \"change\": \"decrease by 10\"}\r\n  ],\r\n  \"requires_adl\": \"false\"\r\n}\r\n\r\n---\r\n\r\nExample 4: ADL action (affects multiple objects)\r\nInput Action:\r\n{\r\n  \"name\": \"unload-all\",\r\n  \"actor\": \"truck\",\r\n  \"parameters\": [{\"name\": \"?t\", \"type\": \"truck\"}, {\"name\": \"?loc\", \"type\": \"location\"}],\r\n  \"preconditions\": [{\"attribute\": \"truck-at\", \"condition\": \"(?t ?loc) = true\"}],\r\n  \"effects\": [{\"attribute\": \"in-truck\", \"change\": \"delete all packages from ?t\"}],\r\n  \"description\": \"Unload all packages\"\r\n}\r\n\r\nExpected Output:\r\n{\r\n  \"name\": \"unload-all\",\r\n  \"description\": \"Unload all packages from truck to current location (requires ADL for forall)\",\r\n  \"actor\": \"truck\",\r\n  \"parameters\": [\r\n    {\"name\": \"?t\", \"type\": \"truck\"},\r\n    {\"name\": \"?loc\", \"type\": \"location\"}\r\n  ],\r\n  \"preconditions\": [\r\n    {\"attribute\": \"truck-at\", \"condition\": \"(?t ?loc) = true\"}\r\n  ],\r\n  \"effects\": [\r\n    {\"attribute\": \"in-truck\", \"change\": \"delete (?p ?t) for all ?p\"},\r\n    {\"attribute\": \"package-at\", \"change\": \"add (?p ?loc) for all ?p in ?t\"}\r\n  ],\r\n  \"requires_adl\": \"true\"\r\n}\r\n\r\n---\r\n\r\nVALIDATION CHECKLIST:\r\n☑ Output has AT LEAST as many actions as input (never fewer)\r\n☑ Every parameter has ? prefix and valid type\r\n☑ Every attribute name exists in the attributes input\r\n☑ Preconditions use correct format: \"(?p1 ?p2) = true/false\" or \"> N\"\r\n☑ Effects use correct format: \"add/delete (?p1 ?p2)\" or \"increase/decrease by N\"\r\n☑ ADL flag is \"true\" or \"false\" (string, not boolean)\r\n\r\n---\r\n\r\nNOW REFINE THE ACTIONS:\r\n\r\nStep 1: Count input actions\r\nStep 2: For EACH action, infer missing preconditions from domain semantics\r\nStep 3: Complete all effects\r\nStep 4: Determine if ADL is needed\r\nStep 5: Verify output count >= input count\r\n\r\nReturn ONLY valid JSON matching the RefinedActionsResult schema:\r\n{\r\n  \"actions\": [\r\n    {\r\n      \"name\": \"action-name\",\r\n      \"description\": \"what it does\",\r\n      \"actor\": \"type-name\",\r\n      \"parameters\": [{\"name\": \"?param\", \"type\": \"type\"}],\r\n      \"preconditions\": [{\"attribute\": \"pred-name\", \"condition\": \"(?p) = true\"}],\r\n      \"effects\": [{\"attribute\": \"pred-name\", \"change\": \"add (?p1 ?p2)\"}],\r\n      \"requires_adl\": \"false\"\r\n    }\r\n  ]\r\n}\r\n\"#\r\n}\r\n",
    "refined_gemini.baml": "// Definisci la classe per un'Azione Raffinata e Aggregata\r\nclass RefinedAction {\r\n    name string @description(\"Nome dell'azione, spesso aggregato (es: 'enter', 'deliver', 'move-safely').\")\r\n    description string @description(\"Descrizione concisa dell'azione raffinata.\")\r\n    actor string @description(\"Tipo di oggetto che esegue l'azione (es: robot, agent)\")\r\n    parameters Parameters[] @description(\"Lista completa dei parametri necessari per l'azione.\")\r\n    preconditions Precondition[] @description(\"Lista di tutte le precondizioni logiche, incluse quelle implicite (es: no ostacoli, porta aperta).\")\r\n    effects Effect[] @description(\"Lista di tutti gli effetti prodotti, aggregati (es: cambia stato, posizione, risorsa).\")\r\n    requires_adl string @description(\"Imposta a true se l'azione usa logica complessa come FORALL/WHEN (che saranno generati nella fase PDDL).\")\r\n}\r\n\r\n// Definisci la classe principale per i risultati\r\nclass RefinedActionsResult {\r\n    actions RefinedAction[] @description(\"Lista di tutte le azioni semplificate, aggregate e semanticamente raffinate.\")\r\n}\r\n\r\n// Funzione BAML di Refactoring\r\nfunction RefineAndAggregateDomainGemini(\r\n    domain_description: string,\r\n    object_types: string,\r\n    attributes: string,\r\n    actions_list: string \r\n) -> RefinedActionsResult {\r\n    client \"CustomGemini\"\r\n    prompt #\"\r\nYou are an expert PDDL domain engineer specializing in semantic inference and action refinement.\r\n\r\nCRITICAL TASK RULES:\r\n1. **PRESERVE ALL ACTIONS**: Output count MUST equal or exceed input count. NEVER remove actions.\r\n2. **INFER IMPLICIT CONSTRAINTS**: Add missing preconditions based on domain semantics\r\n3. **COMPLETE EFFECTS**: Ensure all state changes are explicitly listed\r\n4. **CONSISTENT NAMING**: Use EXACT attribute names from the provided attributes\r\n\r\n---\r\n\r\nINPUTS:\r\n\r\nDomain Description:\r\n{{ domain_description }}\r\n\r\nValid Types (JSON):\r\n{{ object_types }}\r\n\r\nValid Attributes/Predicates (JSON):\r\n{{ attributes }}\r\n\r\nActions to Refine (JSON):\r\n{{ actions_list }}\r\n\r\n---\r\n\r\nREFINEMENT RULES:\r\n\r\nA. PRECONDITION INFERENCE:\r\n   - If domain mentions \"obstacles\", \"blocked\", \"occupied\" → add clearance checks\r\n   - If domain mentions \"capacity\", \"limit\", \"full\" → add resource constraints\r\n   - If action modifies object state → check current state first\r\n   - If action needs empty/available resource → add availability check\r\n   - If locations/positions matter → add location preconditions\r\n\r\nB. EFFECT COMPLETENESS:\r\n   - For movement: delete old location, add new location\r\n   - For pickup: change holder, remove from previous location\r\n   - For resource consumption: decrease/increase numeric fluents\r\n   - For state changes: add new state, delete old state\r\n\r\nC. ADL DETECTION:\r\n   Set requires_adl = \"true\" if:\r\n   - Action affects ALL objects of a type (e.g., \"unload all packages\")\r\n   - Effects depend on conditions (e.g., \"damage if collision\")\r\n   - Quantifiers needed (forall, exists)\r\n   Otherwise: requires_adl = \"false\"\r\n\r\nD. PARAMETER FORMAT:\r\n   - Always include ? prefix: \"?r\", \"?from\", \"?to\"\r\n   - Match types exactly from object_types input\r\n   - Include ALL objects involved in the action\r\n\r\nE. CONDITION/EFFECT FORMAT:\r\n   Preconditions:\r\n   - Predicates: \"(?param1 ?param2) = true\" or \"(?param) = false\"\r\n   - Numeric: \"> 0\", \">= 5\", \"< 100\", \"!= 0\"\r\n   \r\n   Effects:\r\n   - Add predicate: \"add (?p1 ?p2)\"\r\n   - Delete predicate: \"delete (?p1 ?p2)\"\r\n   - Increase: \"increase by 5\"\r\n   - Decrease: \"decrease by 3\"\r\n   - Set: \"set to 100\"\r\n\r\n---\r\n\r\nEXAMPLES:\r\n\r\nExample 1: Simple movement with inferred clearance\r\nInput Action:\r\n{\r\n  \"name\": \"move\",\r\n  \"actor\": \"robot\",\r\n  \"parameters\": [{\"name\": \"?r\", \"type\": \"robot\"}, {\"name\": \"?from\", \"type\": \"location\"}, {\"name\": \"?to\", \"type\": \"location\"}],\r\n  \"preconditions\": [{\"attribute\": \"at\", \"condition\": \"(?r ?from) = true\"}],\r\n  \"effects\": [{\"attribute\": \"at\", \"change\": \"delete (?r ?from)\"}, {\"attribute\": \"at\", \"change\": \"add (?r ?to)\"}],\r\n  \"description\": \"Move robot\"\r\n}\r\n\r\nDomain mentions: \"Some locations are blocked by obstacles\"\r\n\r\nExpected Output:\r\n{\r\n  \"name\": \"move\",\r\n  \"description\": \"Move robot from one location to another if destination is clear\",\r\n  \"actor\": \"robot\",\r\n  \"parameters\": [\r\n    {\"name\": \"?r\", \"type\": \"robot\"},\r\n    {\"name\": \"?from\", \"type\": \"location\"},\r\n    {\"name\": \"?to\", \"type\": \"location\"}\r\n  ],\r\n  \"preconditions\": [\r\n    {\"attribute\": \"at\", \"condition\": \"(?r ?from) = true\"},\r\n    {\"attribute\": \"clear\", \"condition\": \"(?to) = true\"}\r\n  ],\r\n  \"effects\": [\r\n    {\"attribute\": \"at\", \"change\": \"delete (?r ?from)\"},\r\n    {\"attribute\": \"at\", \"change\": \"add (?r ?to)\"}\r\n  ],\r\n  \"requires_adl\": \"false\"\r\n}\r\n\r\n---\r\n\r\nExample 2: Pickup with implicit preconditions\r\nInput Action:\r\n{\r\n  \"name\": \"pickup\",\r\n  \"actor\": \"robot\",\r\n  \"parameters\": [{\"name\": \"?r\", \"type\": \"robot\"}, {\"name\": \"?p\", \"type\": \"package\"}],\r\n  \"preconditions\": [],\r\n  \"effects\": [{\"attribute\": \"holding\", \"change\": \"add (?r ?p)\"}],\r\n  \"description\": \"Pick up package\"\r\n}\r\n\r\nDomain mentions: \"Robot can carry one package at a time. Robot and package must be at same location.\"\r\n\r\nExpected Output:\r\n{\r\n  \"name\": \"pickup\",\r\n  \"description\": \"Robot picks up a package from the same location if hands are empty\",\r\n  \"actor\": \"robot\",\r\n  \"parameters\": [\r\n    {\"name\": \"?r\", \"type\": \"robot\"},\r\n    {\"name\": \"?p\", \"type\": \"package\"},\r\n    {\"name\": \"?loc\", \"type\": \"location\"}\r\n  ],\r\n  \"preconditions\": [\r\n    {\"attribute\": \"at\", \"condition\": \"(?r ?loc) = true\"},\r\n    {\"attribute\": \"at\", \"condition\": \"(?p ?loc) = true\"},\r\n    {\"attribute\": \"hands-empty\", \"condition\": \"(?r) = true\"}\r\n  ],\r\n  \"effects\": [\r\n    {\"attribute\": \"holding\", \"change\": \"add (?r ?p)\"},\r\n    {\"attribute\": \"at\", \"change\": \"delete (?p ?loc)\"},\r\n    {\"attribute\": \"hands-empty\", \"change\": \"delete (?r)\"}\r\n  ],\r\n  \"requires_adl\": \"false\"\r\n}\r\n\r\n---\r\n\r\nExample 3: Action with numeric fluent\r\nInput Action:\r\n{\r\n  \"name\": \"drive\",\r\n  \"actor\": \"truck\",\r\n  \"parameters\": [{\"name\": \"?t\", \"type\": \"truck\"}, {\"name\": \"?from\", \"type\": \"city\"}, {\"name\": \"?to\", \"type\": \"city\"}],\r\n  \"preconditions\": [{\"attribute\": \"truck-at\", \"condition\": \"(?t ?from) = true\"}],\r\n  \"effects\": [{\"attribute\": \"truck-at\", \"change\": \"delete (?t ?from)\"}, {\"attribute\": \"truck-at\", \"change\": \"add (?t ?to)\"}],\r\n  \"description\": \"Drive truck\"\r\n}\r\n\r\nDomain mentions: \"Trucks consume 10 fuel per trip. Fuel ranges 0-100.\"\r\n\r\nExpected Output:\r\n{\r\n  \"name\": \"drive\",\r\n  \"description\": \"Drive truck between cities consuming fuel\",\r\n  \"actor\": \"truck\",\r\n  \"parameters\": [\r\n    {\"name\": \"?t\", \"type\": \"truck\"},\r\n    {\"name\": \"?from\", \"type\": \"city\"},\r\n    {\"name\": \"?to\", \"type\": \"city\"}\r\n  ],\r\n  \"preconditions\": [\r\n    {\"attribute\": \"truck-at\", \"condition\": \"(?t ?from) = true\"},\r\n    {\"attribute\": \"fuel\", \"condition\": \">= 10\"}\r\n  ],\r\n  \"effects\": [\r\n    {\"attribute\": \"truck-at\", \"change\": \"delete (?t ?from)\"},\r\n    {\"attribute\": \"truck-at\", \"change\": \"add (?t ?to)\"},\r\n    {\"attribute\": \"fuel\", \"change\": \"decrease by 10\"}\r\n  ],\r\n  \"requires_adl\": \"false\"\r\n}\r\n\r\n---\r\n\r\nExample 4: ADL action (affects multiple objects)\r\nInput Action:\r\n{\r\n  \"name\": \"unload-all\",\r\n  \"actor\": \"truck\",\r\n  \"parameters\": [{\"name\": \"?t\", \"type\": \"truck\"}, {\"name\": \"?loc\", \"type\": \"location\"}],\r\n  \"preconditions\": [{\"attribute\": \"truck-at\", \"condition\": \"(?t ?loc) = true\"}],\r\n  \"effects\": [{\"attribute\": \"in-truck\", \"change\": \"delete all packages from ?t\"}],\r\n  \"description\": \"Unload all packages\"\r\n}\r\n\r\nExpected Output:\r\n{\r\n  \"name\": \"unload-all\",\r\n  \"description\": \"Unload all packages from truck to current location (requires ADL for forall)\",\r\n  \"actor\": \"truck\",\r\n  \"parameters\": [\r\n    {\"name\": \"?t\", \"type\": \"truck\"},\r\n    {\"name\": \"?loc\", \"type\": \"location\"}\r\n  ],\r\n  \"preconditions\": [\r\n    {\"attribute\": \"truck-at\", \"condition\": \"(?t ?loc) = true\"}\r\n  ],\r\n  \"effects\": [\r\n    {\"attribute\": \"in-truck\", \"change\": \"delete (?p ?t) for all ?p\"},\r\n    {\"attribute\": \"package-at\", \"change\": \"add (?p ?loc) for all ?p in ?t\"}\r\n  ],\r\n  \"requires_adl\": \"true\"\r\n}\r\n\r\n---\r\n\r\nVALIDATION CHECKLIST:\r\n☑ Output has AT LEAST as many actions as input (never fewer)\r\n☑ Every parameter has ? prefix and valid type\r\n☑ Every attribute name exists in the attributes input\r\n☑ Preconditions use correct format: \"(?p1 ?p2) = true/false\" or \"> N\"\r\n☑ Effects use correct format: \"add/delete (?p1 ?p2)\" or \"increase/decrease by N\"\r\n☑ ADL flag is \"true\" or \"false\" (string, not boolean)\r\n\r\n---\r\n\r\nNOW REFINE THE ACTIONS:\r\n\r\nStep 1: Count input actions\r\nStep 2: For EACH action, infer missing preconditions from domain semantics\r\nStep 3: Complete all effects\r\nStep 4: Determine if ADL is needed\r\nStep 5: Verify output count >= input count\r\n\r\nReturn ONLY valid JSON matching the RefinedActionsResult schema:\r\n{\r\n  \"actions\": [\r\n    {\r\n      \"name\": \"action-name\",\r\n      \"description\": \"what it does\",\r\n      \"actor\": \"type-name\",\r\n      \"parameters\": [{\"name\": \"?param\", \"type\": \"type\"}],\r\n      \"preconditions\": [{\"attribute\": \"pred-name\", \"condition\": \"(?p) = true\"}],\r\n      \"effects\": [{\"attribute\": \"pred-name\", \"change\": \"add (?p1 ?p2)\"}],\r\n      \"requires_adl\": \"false\"\r\n    }\r\n  ]\r\n}\r\n\"#\r\n}\r\n",
    "resume.baml": "// Defining a data model.\r\nclass Resume {\r\n  name string\r\n  email string\r\n  experience string[]\r\n  skills string[]\r\n}\r\n\r\n// Create a function to extract the resume from a string.\r\nfunction ExtractResume(resume: string) -> Resume {\r\n  // Specify a client as provider/model-name\r\n  // You can also use custom LLM params with a custom client name from clients.baml like \"client CustomGPT5\" or \"client CustomSonnet4\"\r\n  client \"openai-responses/gpt-5-mini\" // Set OPENAI_API_KEY to use this client.\r\n  prompt #\"\r\n    Extract from this content:\r\n    {{ resume }}\r\n\r\n    {{ ctx.output_format }}\r\n  \"#\r\n}\r\n\r\n\r\n\r\n// Test the function with a sample resume. Open the VSCode playground to run this.\r\ntest vaibhav_resume {\r\n  functions [ExtractResume]\r\n  args {\r\n    resume #\"\r\n      Vaibhav Gupta\r\n      vbv@boundaryml.com\r\n\r\n      Experience:\r\n      - Founder at BoundaryML\r\n      - CV Engineer at Google\r\n      - CV Engineer at Microsoft\r\n\r\n      Skills:\r\n      - Rust\r\n      - C++\r\n    \"#\r\n  }\r\n}\r\n",
}

def get_baml_files():
    return _file_map